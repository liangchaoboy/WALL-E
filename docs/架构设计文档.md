# æ¶æ„è®¾è®¡æ–‡æ¡£ (Architecture Design Document)
# WALL-E: AI é©±åŠ¨çš„æ¡Œé¢æ“ä½œç³»ç»Ÿä»£ç†

---

## ğŸ“‘ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **é¡¹ç›®åç§°** | WALL-E (AI Copilot for PC) |
| **ç‰ˆæœ¬** | v1.0 |
| **æ–‡æ¡£ç±»å‹** | æ¶æ„è®¾è®¡æ–‡æ¡£ (ADD) |
| **åˆ›å»ºæ—¥æœŸ** | 2025-10-26 |
| **åŸºäº** | PRD v3.0 |

---

## 1. æ¶æ„æ¦‚è§ˆ

### 1.1 ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ç”¨æˆ·äº¤äº’å±‚ (UI Layer)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   è¯­éŸ³è¾“å…¥æ¨¡å—              â”‚    â”‚   æ–‡å­—è¾“å…¥æ¨¡å—            â”‚   â”‚
â”‚  â”‚  (Voice Input Module)     â”‚    â”‚  (Text Input Module)     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ â€¢ å”¤é†’è¯æ£€æµ‹ (Porcupine)   â”‚    â”‚ â€¢ ç³»ç»Ÿæ‰˜ç›˜å›¾æ ‡            â”‚   â”‚
â”‚  â”‚ â€¢ éº¦å…‹é£éŸ³é¢‘é‡‡é›†           â”‚    â”‚ â€¢ å…¨å±€å¿«æ·é”® (Cmd+Space) â”‚   â”‚
â”‚  â”‚ â€¢ å®æ—¶éŸ³é¢‘æµå¤„ç†           â”‚    â”‚ â€¢ è¾“å…¥æ¡†ç•Œé¢ (SwiftUI)   â”‚   â”‚
â”‚  â”‚ â€¢ VAD (è¯­éŸ³æ´»åŠ¨æ£€æµ‹)       â”‚    â”‚ â€¢ å†å²è®°å½•æŸ¥çœ‹            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚             â”‚                               â”‚                    â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                             â”‚                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ ¸å¿ƒå¤„ç†å±‚ (Core Layer)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              è¾“å…¥å¤„ç†æ¨¡å— (Input Processor)               â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  STT å¼•æ“ç®¡ç†å™¨                                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚   â”‚
â”‚  â”‚  â”‚ é˜¿é‡Œäº‘ STT   â”‚ â”‚ Whisper STT â”‚ â”‚ æœ¬åœ° STT    â”‚        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚  â”‚  â€¢ è‡ªåŠ¨é™çº§ç­–ç•¥                                           â”‚   â”‚
â”‚  â”‚  â€¢ æ–‡æœ¬é¢„å¤„ç†å’Œæ ‡å‡†åŒ–                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â†“                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            AI ç†è§£å¼•æ“ (AI Understanding Engine)          â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  LLM è°ƒç”¨å±‚                                               â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚   â”‚
â”‚  â”‚  â”‚  ChatGPT    â”‚ â”‚   Claude    â”‚ â”‚  DeepSeek   â”‚        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  æ ¸å¿ƒèƒ½åŠ›:                                                 â”‚   â”‚
â”‚  â”‚  â€¢ æ„å›¾è¯†åˆ« (Intent Recognition)                          â”‚   â”‚
â”‚  â”‚  â€¢ å‚æ•°æå– (Parameter Extraction)                        â”‚   â”‚
â”‚  â”‚  â€¢ ä¸Šä¸‹æ–‡ç®¡ç† (Context Management)                        â”‚   â”‚
â”‚  â”‚  â€¢ å·¥å…·é€‰æ‹© (Tool Selection via MCP)                      â”‚   â”‚
â”‚  â”‚  â€¢ å¤šè½®å¯¹è¯ (Multi-turn Dialog)                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â†“                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              MCP å®¢æˆ·ç«¯ (MCP Client)                      â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  â€¢ MCP Server ç”Ÿå‘½å‘¨æœŸç®¡ç†                                â”‚   â”‚
â”‚  â”‚  â€¢ å·¥å…·å‘ç°å’Œæ³¨å†Œ                                          â”‚   â”‚
â”‚  â”‚  â€¢ å·¥å…·è°ƒç”¨è·¯ç”±                                            â”‚   â”‚
â”‚  â”‚  â€¢ ç»“æœèšåˆå’Œé”™è¯¯å¤„ç†                                       â”‚   â”‚
â”‚  â”‚  â€¢ å·¥å…·é“¾ç¼–æ’ (Multi-step orchestration)                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP å·¥å…·å±‚ (MCP Tools Layer)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ åœ°å›¾å¯¼èˆª     â”‚ â”‚ å¤©æ°”æŸ¥è¯¢     â”‚ â”‚ éŸ³ä¹æ’­æ”¾     â”‚               â”‚
â”‚  â”‚ MCP Server  â”‚ â”‚ MCP Server  â”‚ â”‚ MCP Server  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ æµè§ˆå™¨æ§åˆ¶   â”‚ â”‚ ç³»ç»Ÿæ§åˆ¶     â”‚ â”‚ åº”ç”¨å¯åŠ¨     â”‚               â”‚
â”‚  â”‚ MCP Server  â”‚ â”‚ MCP Server  â”‚ â”‚ MCP Server  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                   â”‚
â”‚  å¯æ‰©å±•æ’ä»¶æ¶æ„ - æ”¯æŒç¬¬ä¸‰æ–¹ MCP Server                            â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ç³»ç»Ÿèƒ½åŠ›å±‚ (System Layer)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â€¢ macOS ç³»ç»Ÿ API (AppKit, Foundation, AVFoundation)             â”‚
â”‚  â€¢ ç¬¬ä¸‰æ–¹æœåŠ¡ API (åœ°å›¾æœåŠ¡ã€å¤©æ°”æœåŠ¡ã€éŸ³ä¹æœåŠ¡)                     â”‚
â”‚  â€¢ æµè§ˆå™¨è‡ªåŠ¨åŒ– (Playwright, AppleScript)                         â”‚
â”‚  â€¢ ç³»ç»Ÿæƒé™ç®¡ç† (Microphone, Accessibility, Network)              â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 2.1 è¯­éŸ³è¾“å…¥æ¨¡å— (Voice Input Module)

#### æŠ€æœ¯æ ˆ
- **è¯­è¨€**: Swift
- **æ¡†æ¶**: AVFoundation (éŸ³é¢‘é‡‡é›†)
- **å”¤é†’è¯å¼•æ“**: Porcupine (æœ¬åœ°æ£€æµ‹)
- **VAD**: WebRTC VAD æˆ– Silero VAD

#### ç»„ä»¶è®¾è®¡

```swift
// å”¤é†’è¯æ£€æµ‹å™¨
class WakeWordDetector {
    private let porcupineManager: PorcupineManager
    
    func start() // å¼€å§‹ç›‘å¬
    func stop()  // åœæ­¢ç›‘å¬
    func onWakeWordDetected(handler: () -> Void) // å”¤é†’å›è°ƒ
}

// éŸ³é¢‘é‡‡é›†å™¨
class AudioCapture {
    private let audioEngine: AVAudioEngine
    
    func startRecording() -> AsyncStream<AudioBuffer>
    func stopRecording()
}

// VAD æ£€æµ‹å™¨
class VoiceActivityDetector {
    func processSample(_ buffer: AudioBuffer) -> Bool // æ˜¯å¦æ£€æµ‹åˆ°è¯­éŸ³
    func didSpeechEnd() -> Bool // æ˜¯å¦è¯´è¯ç»“æŸ
}

// è¯­éŸ³è¾“å…¥åè°ƒå™¨
class VoiceInputCoordinator {
    private let wakeWordDetector: WakeWordDetector
    private let audioCapture: AudioCapture
    private let vad: VoiceActivityDetector
    
    func startListening()
    func onVoiceInput(handler: (Data) -> Void) // è¿”å›éŸ³é¢‘æ•°æ®
}
```

#### æ•°æ®æµ

```
ç”¨æˆ·è¯´è¯ â†’ éº¦å…‹é£é‡‡é›† â†’ å”¤é†’è¯æ£€æµ‹ (Porcupine)
    â†“
æ£€æµ‹åˆ°å”¤é†’è¯ â†’ å¼€å§‹å½•éŸ³ â†’ VAD æ£€æµ‹
    â†“
è¯­éŸ³ç»“æŸ (VAD) â†’ éŸ³é¢‘æ•°æ® â†’ å‘é€è‡³ STT å¼•æ“
```

---

### 2.2 æ–‡å­—è¾“å…¥æ¨¡å— (Text Input Module)

#### æŠ€æœ¯æ ˆ
- **è¯­è¨€**: Swift
- **æ¡†æ¶**: SwiftUI, AppKit

#### ç»„ä»¶è®¾è®¡

```swift
// ç³»ç»Ÿæ‰˜ç›˜ç®¡ç†å™¨
class SystemTrayManager {
    func createStatusBarItem()
    func showInputWindow()
}

// è¾“å…¥çª—å£
struct InputWindow: View {
    @State var inputText: String
    @State var history: [HistoryItem]
    
    var body: some View {
        VStack {
            TextField("è¾“å…¥æŒ‡ä»¤...", text: $inputText)
            HistoryListView(history: history)
        }
    }
}

// å…¨å±€å¿«æ·é”®ç®¡ç†å™¨
class GlobalHotKeyManager {
    func registerHotKey(_ key: KeyCombo, handler: () -> Void)
}

// æ–‡å­—è¾“å…¥åè°ƒå™¨
class TextInputCoordinator {
    private let trayManager: SystemTrayManager
    private let hotKeyManager: GlobalHotKeyManager
    
    func setupUI()
    func onTextInput(handler: (String) -> Void)
}
```

---

### 2.3 è¾“å…¥å¤„ç†æ¨¡å— (Input Processor)

#### æŠ€æœ¯æ ˆ
- **è¯­è¨€**: Go
- **STT å¼•æ“**:
  - é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ« SDK
  - OpenAI Whisper API
  - æœ¬åœ° Whisper æ¨¡å‹ (whisper.cpp)

#### ç»„ä»¶è®¾è®¡

```go
// STT å¼•æ“æ¥å£
type STTEngine interface {
    Transcribe(audioData []byte) (string, error)
}

// é˜¿é‡Œäº‘ STT
type AliyunSTT struct {
    client *alibabacloud.Client
}

// Whisper STT
type WhisperSTT struct {
    apiKey string
}

// æœ¬åœ° Whisper
type LocalWhisperSTT struct {
    modelPath string
}

// STT ç®¡ç†å™¨ (æ”¯æŒé™çº§ç­–ç•¥)
type STTManager struct {
    engines []STTEngine
    fallbackEnabled bool
}

func (m *STTManager) Transcribe(audio []byte) (string, error) {
    // ä¾æ¬¡å°è¯•å„å¼•æ“,å¤±è´¥åˆ™é™çº§
    for _, engine := range m.engines {
        text, err := engine.Transcribe(audio)
        if err == nil {
            return text, nil
        }
    }
    return "", errors.New("all STT engines failed")
}
```

#### æ–‡æœ¬é¢„å¤„ç†

```go
type TextPreprocessor struct{}

func (p *TextPreprocessor) Normalize(text string) string {
    // 1. å»é™¤å¤šä½™ç©ºæ ¼
    // 2. ç¹ç®€è½¬æ¢
    // 3. æ ‡ç‚¹æ ‡å‡†åŒ–
    // 4. æ•°å­—è§„èŒƒåŒ– (å¦‚"ä¸€ç™¾" -> "100")
    return normalizedText
}
```

---

### 2.4 AI ç†è§£å¼•æ“ (AI Understanding Engine)

#### æŠ€æœ¯æ ˆ
- **è¯­è¨€**: Go
- **LLM**: æ”¯æŒå¤šç§ LLM (ChatGPT, Claude, DeepSeek)
- **åè®®**: MCP (Model Context Protocol)

#### æ ¸å¿ƒè®¾è®¡

```go
// LLM å®¢æˆ·ç«¯æ¥å£
type LLMClient interface {
    Chat(ctx context.Context, messages []Message, tools []Tool) (*Response, error)
}

// æ„å›¾ç†è§£ç»“æœ
type Intent struct {
    Name       string                 // æ„å›¾åç§° (å¦‚ "navigate_map")
    Confidence float64                // ç½®ä¿¡åº¦
    Parameters map[string]interface{} // å‚æ•°
    ToolCalls  []ToolCall             // éœ€è¦è°ƒç”¨çš„å·¥å…·
}

// AI ç†è§£å¼•æ“
type AIEngine struct {
    llmClient    LLMClient
    mcpClient    *MCPClient
    contextStore *ContextStore // ä¸Šä¸‹æ–‡å­˜å‚¨
}

func (e *AIEngine) Understand(ctx context.Context, input string) (*Intent, error) {
    // 1. è·å–ä¸Šä¸‹æ–‡
    context := e.contextStore.GetContext()
    
    // 2. æ„é€ æ¶ˆæ¯
    messages := e.buildMessages(input, context)
    
    // 3. è·å–å¯ç”¨å·¥å…·åˆ—è¡¨
    tools := e.mcpClient.GetAvailableTools()
    
    // 4. è°ƒç”¨ LLM (æ”¯æŒ Function Calling)
    response, err := e.llmClient.Chat(ctx, messages, tools)
    if err != nil {
        return nil, err
    }
    
    // 5. è§£ææ„å›¾å’Œå‚æ•°
    intent := e.parseIntent(response)
    
    // 6. æ›´æ–°ä¸Šä¸‹æ–‡
    e.contextStore.UpdateContext(input, intent)
    
    return intent, nil
}
```

#### ä¸Šä¸‹æ–‡ç®¡ç†

```go
type ContextStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    SessionID   string
    Messages    []Message
    LastIntent  *Intent
    CreatedAt   time.Time
    LastActiveAt time.Time
}

func (c *ContextStore) GetContext() []Message {
    // è¿”å›æœ€è¿‘ N è½®å¯¹è¯å†å²
}

func (c *ContextStore) UpdateContext(input string, intent *Intent) {
    // æ›´æ–°ä¼šè¯çŠ¶æ€
}
```

---

### 2.5 MCP å®¢æˆ·ç«¯ (MCP Client)

#### æŠ€æœ¯æ ˆ
- **è¯­è¨€**: Go
- **SDK**: github.com/modelcontextprotocol/sdk-go

#### æ ¸å¿ƒè®¾è®¡

```go
// MCP å®¢æˆ·ç«¯
type MCPClient struct {
    servers map[string]*MCPServer
    tools   map[string]*Tool
}

// MCP Server è¿æ¥
type MCPServer struct {
    Name       string
    Connection *mcp.Connection
    Status     ServerStatus
}

// å·¥å…·å®šä¹‰
type Tool struct {
    Name        string
    Description string
    InputSchema JSONSchema
    ServerName  string
}

// å¯åŠ¨æ‰€æœ‰ MCP Server
func (c *MCPClient) StartServers(configs []ServerConfig) error {
    for _, config := range configs {
        server, err := c.connectServer(config)
        if err != nil {
            log.Errorf("failed to connect server %s: %v", config.Name, err)
            continue
        }
        c.servers[config.Name] = server
        
        // å‘ç°å·¥å…·
        tools, err := server.ListTools()
        if err != nil {
            log.Errorf("failed to list tools from %s: %v", config.Name, err)
            continue
        }
        
        // æ³¨å†Œå·¥å…·
        for _, tool := range tools {
            c.tools[tool.Name] = tool
        }
    }
    return nil
}

// è°ƒç”¨å·¥å…·
func (c *MCPClient) CallTool(ctx context.Context, toolName string, params map[string]interface{}) (*ToolResult, error) {
    tool, exists := c.tools[toolName]
    if !exists {
        return nil, fmt.Errorf("tool %s not found", toolName)
    }
    
    // éªŒè¯å‚æ•°
    if err := tool.ValidateParams(params); err != nil {
        return nil, err
    }
    
    // è·å–å¯¹åº”çš„ server
    server := c.servers[tool.ServerName]
    
    // è°ƒç”¨å·¥å…·
    result, err := server.CallTool(ctx, toolName, params)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}

// è·å–å¯ç”¨å·¥å…·åˆ—è¡¨ (ä¾› LLM Function Calling ä½¿ç”¨)
func (c *MCPClient) GetAvailableTools() []Tool {
    tools := make([]Tool, 0, len(c.tools))
    for _, tool := range c.tools {
        tools = append(tools, *tool)
    }
    return tools
}
```

#### å·¥å…·é“¾ç¼–æ’

```go
// å·¥å…·é“¾ç¼–æ’å™¨ (æ”¯æŒå¤šæ­¥éª¤æ“ä½œ)
type ToolOrchestrator struct {
    mcpClient *MCPClient
}

func (o *ToolOrchestrator) ExecuteChain(ctx context.Context, toolCalls []ToolCall) ([]ToolResult, error) {
    results := make([]ToolResult, 0, len(toolCalls))
    
    for _, call := range toolCalls {
        result, err := o.mcpClient.CallTool(ctx, call.Name, call.Parameters)
        if err != nil {
            // é”™è¯¯å¤„ç†: ç»§ç»­æ‰§è¡Œè¿˜æ˜¯ä¸­æ–­?
            if call.Required {
                return results, err
            }
            log.Warnf("optional tool %s failed: %v", call.Name, err)
            continue
        }
        results = append(results, *result)
    }
    
    return results, nil
}
```

---

### 2.6 MCP å·¥å…·å±‚ (MCP Tools)

#### 2.6.1 åœ°å›¾å¯¼èˆªå·¥å…·

**å®ç°è¯­è¨€**: TypeScript/Node.js

```typescript
// åœ°å›¾å¯¼èˆª MCP Server
import { Server } from '@modelcontextprotocol/sdk';

const server = new Server({
  name: 'map-navigation',
  version: '1.0.0',
});

server.setRequestHandler('tools/list', async () => ({
  tools: [
    {
      name: 'navigate_map',
      description: 'æ‰“å¼€åœ°å›¾åº”ç”¨å¹¶å¯¼èˆªåˆ°æŒ‡å®šåœ°ç‚¹',
      inputSchema: {
        type: 'object',
        properties: {
          origin: { type: 'string', description: 'èµ·ç‚¹åœ°å€' },
          destination: { type: 'string', description: 'ç›®çš„åœ°åœ°å€' },
          mapProvider: { 
            type: 'string', 
            enum: ['baidu', 'amap', 'google'],
            default: 'baidu' 
          },
          routeType: {
            type: 'string',
            enum: ['driving', 'walking', 'transit', 'cycling'],
            default: 'driving'
          }
        },
        required: ['destination']
      }
    }
  ]
}));

server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  
  if (name === 'navigate_map') {
    const url = buildMapURL(args);
    await openURL(url); // ä½¿ç”¨ macOS open å‘½ä»¤æˆ–æµè§ˆå™¨æ‰“å¼€
    
    return {
      content: [
        {
          type: 'text',
          text: `å·²æ‰“å¼€åœ°å›¾å¯¼èˆª: ${args.origin || 'å½“å‰ä½ç½®'} â†’ ${args.destination}`
        }
      ]
    };
  }
});
```

#### 2.6.2 å¤©æ°”æŸ¥è¯¢å·¥å…·

**å®ç°è¯­è¨€**: Python

```python
from mcp.server import Server
from mcp.types import Tool, TextContent
import requests

app = Server("weather-query")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="query_weather",
            description="æŸ¥è¯¢æŒ‡å®šåœ°ç‚¹çš„å¤©æ°”ä¿¡æ¯",
            inputSchema={
                "type": "object",
                "properties": {
                    "location": {"type": "string", "description": "åœ°ç‚¹åç§°"},
                    "date": {"type": "string", "description": "æ—¥æœŸ (today/tomorrow/æ—¥æœŸ)"},
                },
                "required": ["location"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "query_weather":
        location = arguments["location"]
        date = arguments.get("date", "today")
        
        # è°ƒç”¨å¤©æ°” API (å½©äº‘å¤©æ°”/å’Œé£å¤©æ°”)
        weather_data = fetch_weather(location, date)
        
        return [
            TextContent(
                type="text",
                text=format_weather_info(weather_data)
            )
        ]
```

#### 2.6.3 éŸ³ä¹æ’­æ”¾å·¥å…·

**å®ç°è¯­è¨€**: Go

```go
package main

import (
    "github.com/modelcontextprotocol/sdk-go/mcp"
)

func main() {
    server := mcp.NewServer("music-player", "1.0.0")
    
    server.HandleListTools(func() ([]mcp.Tool, error) {
        return []mcp.Tool{
            {
                Name:        "play_music",
                Description: "æ’­æ”¾æŒ‡å®šçš„éŸ³ä¹",
                InputSchema: map[string]interface{}{
                    "type": "object",
                    "properties": map[string]interface{}{
                        "song":   map[string]string{"type": "string", "description": "æ­Œæ›²åç§°"},
                        "artist": map[string]string{"type": "string", "description": "æ­Œæ‰‹åç§°"},
                        "app":    map[string]interface{}{
                            "type": "string",
                            "enum": []string{"netease", "qq", "spotify", "apple"},
                            "default": "netease",
                        },
                    },
                    "required": []string{"song"},
                },
            },
        }, nil
    })
    
    server.HandleCallTool(func(name string, params map[string]interface{}) (*mcp.ToolResult, error) {
        if name == "play_music" {
            // é€šè¿‡ AppleScript æˆ– API æ§åˆ¶éŸ³ä¹åº”ç”¨
            err := playMusicViaAppleScript(params)
            if err != nil {
                return nil, err
            }
            return &mcp.ToolResult{
                Content: []mcp.Content{
                    {Type: "text", Text: "æ­£åœ¨æ’­æ”¾éŸ³ä¹..."},
                },
            }, nil
        }
        return nil, fmt.Errorf("unknown tool: %s", name)
    })
    
    server.Start()
}
```

---

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 é…ç½®æ•°æ®

```go
// åº”ç”¨é…ç½®
type AppConfig struct {
    // è¯­éŸ³é…ç½®
    Voice struct {
        WakeWord       string   `json:"wake_word"`        // å”¤é†’è¯
        STTEngine      string   `json:"stt_engine"`       // é»˜è®¤ STT å¼•æ“
        STTFallback    bool     `json:"stt_fallback"`     // æ˜¯å¦å¯ç”¨é™çº§
        VADSensitivity float64  `json:"vad_sensitivity"`  // VAD çµæ•åº¦
    } `json:"voice"`
    
    // AI é…ç½®
    AI struct {
        LLMProvider string `json:"llm_provider"` // ChatGPT/Claude/DeepSeek
        APIKey      string `json:"api_key"`
        Model       string `json:"model"`
        Temperature float64 `json:"temperature"`
    } `json:"ai"`
    
    // MCP é…ç½®
    MCP struct {
        Servers []ServerConfig `json:"servers"`
    } `json:"mcp"`
    
    // UI é…ç½®
    UI struct {
        HotKey      string `json:"hot_key"`       // å…¨å±€å¿«æ·é”®
        LaunchAtLogin bool `json:"launch_at_login"`
    } `json:"ui"`
}

// MCP Server é…ç½®
type ServerConfig struct {
    Name    string                 `json:"name"`
    Command string                 `json:"command"` // å¯åŠ¨å‘½ä»¤
    Args    []string               `json:"args"`
    Env     map[string]string      `json:"env"`
    Enabled bool                   `json:"enabled"`
}
```

### 3.2 æŒä¹…åŒ–æ•°æ®

```go
// å†å²è®°å½•
type HistoryItem struct {
    ID        string    `db:"id"`
    SessionID string    `db:"session_id"`
    Input     string    `db:"input"`      // ç”¨æˆ·è¾“å…¥
    Intent    string    `db:"intent"`     // è¯†åˆ«çš„æ„å›¾
    ToolCalls string    `db:"tool_calls"` // JSON åºåˆ—åŒ–çš„å·¥å…·è°ƒç”¨
    Result    string    `db:"result"`     // æ‰§è¡Œç»“æœ
    Success   bool      `db:"success"`
    CreatedAt time.Time `db:"created_at"`
}

// ä½¿ç”¨ç»Ÿè®¡
type UsageStats struct {
    Date       string `db:"date"`        // YYYY-MM-DD
    ToolName   string `db:"tool_name"`
    CallCount  int    `db:"call_count"`
    SuccessRate float64 `db:"success_rate"`
}
```

---

## 4. é€šä¿¡åè®®è®¾è®¡

### 4.1 Swift â†” Go è¿›ç¨‹é—´é€šä¿¡

**æ–¹æ¡ˆ**: gRPC

```protobuf
syntax = "proto3";

package wallecli;

// æ ¸å¿ƒæœåŠ¡
service WALLEService {
    // å¤„ç†æ–‡å­—è¾“å…¥
    rpc ProcessTextInput(TextInputRequest) returns (TextInputResponse);
    
    // å¤„ç†è¯­éŸ³è¾“å…¥
    rpc ProcessVoiceInput(VoiceInputRequest) returns (VoiceInputResponse);
    
    // è·å–å†å²è®°å½•
    rpc GetHistory(HistoryRequest) returns (HistoryResponse);
    
    // è·å–é…ç½®
    rpc GetConfig(ConfigRequest) returns (ConfigResponse);
    
    // æ›´æ–°é…ç½®
    rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);
}

message TextInputRequest {
    string input = 1;
    string session_id = 2;
}

message VoiceInputRequest {
    bytes audio_data = 1;
    string audio_format = 2; // wav, pcm
    string session_id = 3;
}

message TextInputResponse {
    string intent = 1;
    map<string, string> parameters = 2;
    repeated ToolCallResult tool_results = 3;
    string feedback_text = 4; // åé¦ˆæ–‡æœ¬ (ç”¨äº TTS)
    bool success = 5;
}

message ToolCallResult {
    string tool_name = 1;
    bool success = 2;
    string result = 3;
    string error = 4;
}
```

### 4.2 MCP åè®®é€šä¿¡

éµå¾ª MCP æ ‡å‡†åè®® (åŸºäº JSON-RPC 2.0)

**ç¤ºä¾‹: å·¥å…·è°ƒç”¨è¯·æ±‚**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "navigate_map",
    "arguments": {
      "origin": "ä¸Šæµ·ä¸ƒç‰›äº‘",
      "destination": "è™¹æ¡¥æœºåœº",
      "mapProvider": "baidu",
      "routeType": "driving"
    }
  }
}
```

**ç¤ºä¾‹: å·¥å…·è°ƒç”¨å“åº”**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "å·²æ‰“å¼€ç™¾åº¦åœ°å›¾å¯¼èˆª: ä¸Šæµ·ä¸ƒç‰›äº‘ â†’ è™¹æ¡¥æœºåœº"
      }
    ],
    "isError": false
  }
}
```

---

## 5. å®‰å…¨è®¾è®¡

### 5.1 æƒé™ç®¡ç†

```go
// å±é™©æ“ä½œåˆ—è¡¨
var DangerousTools = map[string]bool{
    "system_shutdown":  true,
    "system_restart":   true,
    "delete_file":      true,
    "execute_command":  true,
}

// æƒé™æ£€æŸ¥å™¨
type PermissionChecker struct {
    userConfirmations map[string]bool // ç”¨æˆ·å·²ç¡®è®¤çš„æ“ä½œ
}

func (p *PermissionChecker) CheckPermission(toolName string) (bool, error) {
    if DangerousTools[toolName] {
        // å±é™©æ“ä½œéœ€è¦ç”¨æˆ·ç¡®è®¤
        if !p.userConfirmations[toolName] {
            return false, errors.New("éœ€è¦ç”¨æˆ·ç¡®è®¤")
        }
    }
    return true, nil
}
```

### 5.2 æ•æ„Ÿæ•°æ®ä¿æŠ¤

```go
// ä½¿ç”¨ macOS Keychain å­˜å‚¨æ•æ„Ÿä¿¡æ¯
type SecureStorage struct {
    keychain *Keychain
}

func (s *SecureStorage) StoreAPIKey(provider string, apiKey string) error {
    return s.keychain.Set(fmt.Sprintf("wallecli.apikey.%s", provider), apiKey)
}

func (s *SecureStorage) GetAPIKey(provider string) (string, error) {
    return s.keychain.Get(fmt.Sprintf("wallecli.apikey.%s", provider))
}
```

### 5.3 æ—¥å¿—è„±æ•

```go
// æ—¥å¿—è„±æ•
type SensitiveFilter struct {
    patterns []string // æ•æ„Ÿä¿¡æ¯æ­£åˆ™
}

func (f *SensitiveFilter) Filter(log string) string {
    // æ›¿æ¢å¯†ç ã€Tokenã€API Key ç­‰æ•æ„Ÿä¿¡æ¯
    filtered := log
    for _, pattern := range f.patterns {
        re := regexp.MustCompile(pattern)
        filtered = re.ReplaceAllString(filtered, "***")
    }
    return filtered
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 å¯åŠ¨ä¼˜åŒ–

- **æ‡’åŠ è½½**: MCP Server æŒ‰éœ€å¯åŠ¨,è€Œéå…¨éƒ¨é¢„åŠ è½½
- **å¹¶å‘å¯åŠ¨**: å¤šä¸ª MCP Server å¹¶å‘å¯åŠ¨
- **ç¼“å­˜**: å·¥å…·åˆ—è¡¨ç¼“å­˜,é¿å…é‡å¤æŸ¥è¯¢

```go
func (c *MCPClient) LazyLoadServer(serverName string) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if _, exists := c.servers[serverName]; exists {
        return nil // å·²åŠ è½½
    }
    
    config := c.configs[serverName]
    server, err := c.connectServer(config)
    if err != nil {
        return err
    }
    
    c.servers[serverName] = server
    return nil
}
```

### 6.2 å†…å­˜ä¼˜åŒ–

- **éŸ³é¢‘æµå¤„ç†**: ä½¿ç”¨æµå¼å¤„ç†,é¿å…å¤§å—å†…å­˜åˆ†é…
- **ä¸Šä¸‹æ–‡ç®¡ç†**: é™åˆ¶ä¸Šä¸‹æ–‡å†å²é•¿åº¦ (å¦‚æœ€å¤šä¿ç•™ 10 è½®å¯¹è¯)
- **å®šæœŸæ¸…ç†**: å®šæœŸæ¸…ç†è¿‡æœŸçš„ä¼šè¯æ•°æ®

### 6.3 å“åº”ä¼˜åŒ–

- **å¹¶è¡Œè°ƒç”¨**: ç‹¬ç«‹å·¥å…·å¹¶è¡Œè°ƒç”¨
- **è¶…æ—¶æ§åˆ¶**: æ¯ä¸ªå·¥å…·è°ƒç”¨è®¾ç½®è¶…æ—¶
- **é™çº§ç­–ç•¥**: å·¥å…·å¤±è´¥æ—¶å¿«é€Ÿé™çº§

---

## 7. å¯æ‰©å±•æ€§è®¾è®¡

### 7.1 æ’ä»¶ç³»ç»Ÿ

æ”¯æŒç¬¬ä¸‰æ–¹å¼€å‘ MCP Server æ’ä»¶

```yaml
# æ’ä»¶å¸‚åœºé…ç½®ç¤ºä¾‹
plugins:
  - name: weather-extended
    author: community
    version: 1.2.0
    description: å¢å¼ºç‰ˆå¤©æ°”æŸ¥è¯¢å·¥å…·
    install_command: npm install -g @wallecli/weather-extended
    server_config:
      command: weather-extended-server
      args: []
```

### 7.2 é…ç½®çƒ­æ›´æ–°

æ”¯æŒæ— éœ€é‡å¯çš„é…ç½®æ›´æ–°

```go
type ConfigWatcher struct {
    configPath string
    onChange   func(*AppConfig)
}

func (w *ConfigWatcher) Watch() {
    // ç›‘å¬é…ç½®æ–‡ä»¶å˜åŒ–
    // å˜åŒ–æ—¶é‡æ–°åŠ è½½å¹¶è§¦å‘ onChange å›è°ƒ
}
```

---

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 å•å…ƒæµ‹è¯•

- **è¦†ç›–ç‡ç›®æ ‡**: > 80%
- **Mock**: ä½¿ç”¨ Mock éš”ç¦»å¤–éƒ¨ä¾èµ– (LLM API, MCP Server)

### 8.2 é›†æˆæµ‹è¯•

```go
func TestEndToEndFlow(t *testing.T) {
    // å¯åŠ¨æµ‹è¯•ç”¨ MCP Server
    testServer := startTestMCPServer()
    defer testServer.Stop()
    
    // åˆ›å»º AI å¼•æ“ (ä½¿ç”¨ Mock LLM)
    engine := NewAIEngine(mockLLM, testMCPClient)
    
    // æµ‹è¯•è¾“å…¥
    input := "æŸ¥çœ‹æ˜å¤©ä¸Šæµ·çš„å¤©æ°”"
    
    // æ‰§è¡Œ
    intent, err := engine.Understand(context.Background(), input)
    require.NoError(t, err)
    
    // éªŒè¯
    assert.Equal(t, "query_weather", intent.Name)
    assert.Equal(t, "ä¸Šæµ·", intent.Parameters["location"])
    assert.Equal(t, "tomorrow", intent.Parameters["date"])
}
```

### 8.3 æ€§èƒ½æµ‹è¯•

- **å¯åŠ¨æ—¶é—´**: < 2s
- **ç«¯åˆ°ç«¯å»¶è¿Ÿ**: æ–‡å­—è¾“å…¥ < 5s, è¯­éŸ³è¾“å…¥ < 10s
- **å†…å­˜å ç”¨**: ç©ºé—² < 200MB, è¿è¡Œ < 500MB

---

## 9. éƒ¨ç½²æ¶æ„

### 9.1 åº”ç”¨ç»“æ„

```
WALLE.app/
â”œâ”€â”€ Contents/
â”‚   â”œâ”€â”€ MacOS/
â”‚   â”‚   â”œâ”€â”€ WALLE              # Swift å¯æ‰§è¡Œæ–‡ä»¶ (UI + è¯­éŸ³)
â”‚   â”‚   â””â”€â”€ walle-core         # Go å¯æ‰§è¡Œæ–‡ä»¶ (æ ¸å¿ƒå¤„ç†)
â”‚   â”œâ”€â”€ Resources/
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â””â”€â”€ wakeword.ppn   # å”¤é†’è¯æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ configs/
â”‚   â”‚   â”‚   â””â”€â”€ default.json   # é»˜è®¤é…ç½®
â”‚   â”‚   â””â”€â”€ mcp-servers/       # å†…ç½® MCP Server
â”‚   â”‚       â”œâ”€â”€ map-navigation/
â”‚   â”‚       â”œâ”€â”€ weather-query/
â”‚   â”‚       â””â”€â”€ music-player/
â”‚   â””â”€â”€ Info.plist
```

### 9.2 è¿›ç¨‹ç®¡ç†

- **ä¸»è¿›ç¨‹**: Swift åº”ç”¨ (UI)
- **å­è¿›ç¨‹**: Go æ ¸å¿ƒæœåŠ¡ (gRPC Server)
- **MCP Server è¿›ç¨‹**: æŒ‰éœ€å¯åŠ¨çš„ç‹¬ç«‹è¿›ç¨‹

```swift
// Swift ä¸­å¯åŠ¨ Go æ ¸å¿ƒæœåŠ¡
class CoreServiceManager {
    func startCoreService() {
        let corePath = Bundle.main.path(forResource: "walle-core", ofType: nil)!
        let process = Process()
        process.executableURL = URL(fileURLWithPath: corePath)
        process.arguments = ["--port", "50051"]
        try? process.run()
    }
}
```

---

## 10. ç›‘æ§ä¸æ—¥å¿—

### 10.1 æ—¥å¿—åˆ†çº§

```go
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿— (å¦‚ zap)
logger := zap.NewProduction()

logger.Info("user input received",
    zap.String("input", userInput),
    zap.String("session_id", sessionID),
)

logger.Error("tool call failed",
    zap.String("tool", toolName),
    zap.Error(err),
)
```

### 10.2 æ€§èƒ½æŒ‡æ ‡é‡‡é›†

```go
// è®°å½•å…³é”®æ“ä½œçš„è€—æ—¶
type Metrics struct {
    STTLatency     prometheus.Histogram
    AILatency      prometheus.Histogram
    ToolCallLatency prometheus.Histogram
}

func (m *Metrics) RecordSTTLatency(duration time.Duration) {
    m.STTLatency.Observe(duration.Seconds())
}
```

---

## 11. æ€»ç»“

æœ¬æ¶æ„è®¾è®¡æ–‡æ¡£è¯¦ç»†æè¿°äº† WALL-E ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„,åŒ…æ‹¬:

1. **åˆ†å±‚æ¶æ„**: ç”¨æˆ·äº¤äº’å±‚ â†’ æ ¸å¿ƒå¤„ç†å±‚ â†’ MCP å·¥å…·å±‚ â†’ ç³»ç»Ÿèƒ½åŠ›å±‚
2. **æ ¸å¿ƒæ¨¡å—**: è¯­éŸ³è¾“å…¥ã€æ–‡å­—è¾“å…¥ã€STTã€AI ç†è§£ã€MCP å®¢æˆ·ç«¯
3. **MCP å·¥å…·**: åœ°å›¾å¯¼èˆªã€å¤©æ°”æŸ¥è¯¢ã€éŸ³ä¹æ’­æ”¾ç­‰å¯æ‰©å±•å·¥å…·
4. **é€šä¿¡åè®®**: gRPC (è¿›ç¨‹é—´) + MCP (å·¥å…·è°ƒç”¨)
5. **å®‰å…¨è®¾è®¡**: æƒé™ç®¡ç†ã€æ•°æ®åŠ å¯†ã€æ—¥å¿—è„±æ•
6. **æ€§èƒ½ä¼˜åŒ–**: æ‡’åŠ è½½ã€å¹¶å‘ã€ç¼“å­˜
7. **å¯æ‰©å±•æ€§**: æ’ä»¶ç³»ç»Ÿã€é…ç½®çƒ­æ›´æ–°

è¯¥æ¶æ„æ”¯æŒå¿«é€Ÿè¿­ä»£,å¯ä» MVP é€æ­¥æ¼”è¿›åˆ°å®Œæ•´äº§å“ã€‚
