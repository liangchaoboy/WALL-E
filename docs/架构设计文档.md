# 架构设计文档 (Architecture Design Document)
# WALL-E: AI 驱动的桌面操作系统代理

---

## 📑 文档信息

| 项目 | 内容 |
|------|------|
| **项目名称** | WALL-E (AI Copilot for PC) |
| **版本** | v1.0 |
| **文档类型** | 架构设计文档 (ADD) |
| **创建日期** | 2025-10-26 |
| **基于** | PRD v3.0 |

---

## 1. 架构概览

### 1.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户交互层 (UI Layer)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────┐    ┌──────────────────────────┐   │
│  │   语音输入模块              │    │   文字输入模块            │   │
│  │  (Voice Input Module)     │    │  (Text Input Module)     │   │
│  ├──────────────────────────┤    ├──────────────────────────┤   │
│  │ • 唤醒词检测 (Porcupine)   │    │ • 系统托盘图标            │   │
│  │ • 麦克风音频采集           │    │ • 全局快捷键 (Cmd+Space) │   │
│  │ • 实时音频流处理           │    │ • 输入框界面 (SwiftUI)   │   │
│  │ • VAD (语音活动检测)       │    │ • 历史记录查看            │   │
│  └──────────┬───────────────┘    └──────────┬───────────────┘   │
│             │                               │                    │
│             └───────────────┬───────────────┘                    │
│                             │                                    │
└─────────────────────────────┼────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      核心处理层 (Core Layer)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              输入处理模块 (Input Processor)               │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  STT 引擎管理器                                           │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │   │
│  │  │ 阿里云 STT   │ │ Whisper STT │ │ 本地 STT    │        │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘        │   │
│  │  • 自动降级策略                                           │   │
│  │  • 文本预处理和标准化                                      │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         ↓                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            AI 理解引擎 (AI Understanding Engine)          │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  LLM 调用层                                               │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │   │
│  │  │  ChatGPT    │ │   Claude    │ │  DeepSeek   │        │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘        │   │
│  │                                                            │   │
│  │  核心能力:                                                 │   │
│  │  • 意图识别 (Intent Recognition)                          │   │
│  │  • 参数提取 (Parameter Extraction)                        │   │
│  │  • 上下文管理 (Context Management)                        │   │
│  │  • 工具选择 (Tool Selection via MCP)                      │   │
│  │  • 多轮对话 (Multi-turn Dialog)                           │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         ↓                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              MCP 客户端 (MCP Client)                      │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  • MCP Server 生命周期管理                                │   │
│  │  • 工具发现和注册                                          │   │
│  │  • 工具调用路由                                            │   │
│  │  • 结果聚合和错误处理                                       │   │
│  │  • 工具链编排 (Multi-step orchestration)                  │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
└─────────────────────────┼────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                    MCP 工具层 (MCP Tools Layer)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │ 地图导航     │ │ 天气查询     │ │ 音乐播放     │               │
│  │ MCP Server  │ │ MCP Server  │ │ MCP Server  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
│                                                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │ 浏览器控制   │ │ 系统控制     │ │ 应用启动     │               │
│  │ MCP Server  │ │ MCP Server  │ │ MCP Server  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
│                                                                   │
│  可扩展插件架构 - 支持第三方 MCP Server                            │
│                                                                   │
└─────────────────────────┬───────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                   系统能力层 (System Layer)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  • macOS 系统 API (AppKit, Foundation, AVFoundation)             │
│  • 第三方服务 API (地图服务、天气服务、音乐服务)                     │
│  • 浏览器自动化 (Playwright, AppleScript)                         │
│  • 系统权限管理 (Microphone, Accessibility, Network)              │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心模块设计

### 2.1 语音输入模块 (Voice Input Module)

#### 技术栈
- **语言**: Swift
- **框架**: AVFoundation (音频采集)
- **唤醒词引擎**: Porcupine (本地检测)
- **VAD**: WebRTC VAD 或 Silero VAD

#### 组件设计

```swift
// 唤醒词检测器
class WakeWordDetector {
    private let porcupineManager: PorcupineManager
    
    func start() // 开始监听
    func stop()  // 停止监听
    func onWakeWordDetected(handler: () -> Void) // 唤醒回调
}

// 音频采集器
class AudioCapture {
    private let audioEngine: AVAudioEngine
    
    func startRecording() -> AsyncStream<AudioBuffer>
    func stopRecording()
}

// VAD 检测器
class VoiceActivityDetector {
    func processSample(_ buffer: AudioBuffer) -> Bool // 是否检测到语音
    func didSpeechEnd() -> Bool // 是否说话结束
}

// 语音输入协调器
class VoiceInputCoordinator {
    private let wakeWordDetector: WakeWordDetector
    private let audioCapture: AudioCapture
    private let vad: VoiceActivityDetector
    
    func startListening()
    func onVoiceInput(handler: (Data) -> Void) // 返回音频数据
}
```

#### 数据流

```
用户说话 → 麦克风采集 → 唤醒词检测 (Porcupine)
    ↓
检测到唤醒词 → 开始录音 → VAD 检测
    ↓
语音结束 (VAD) → 音频数据 → 发送至 STT 引擎
```

---

### 2.2 文字输入模块 (Text Input Module)

#### 技术栈
- **语言**: Swift
- **框架**: SwiftUI, AppKit

#### 组件设计

```swift
// 系统托盘管理器
class SystemTrayManager {
    func createStatusBarItem()
    func showInputWindow()
}

// 输入窗口
struct InputWindow: View {
    @State var inputText: String
    @State var history: [HistoryItem]
    
    var body: some View {
        VStack {
            TextField("输入指令...", text: $inputText)
            HistoryListView(history: history)
        }
    }
}

// 全局快捷键管理器
class GlobalHotKeyManager {
    func registerHotKey(_ key: KeyCombo, handler: () -> Void)
}

// 文字输入协调器
class TextInputCoordinator {
    private let trayManager: SystemTrayManager
    private let hotKeyManager: GlobalHotKeyManager
    
    func setupUI()
    func onTextInput(handler: (String) -> Void)
}
```

---

### 2.3 输入处理模块 (Input Processor)

#### 技术栈
- **语言**: Go
- **STT 引擎**:
  - 阿里云语音识别 SDK
  - OpenAI Whisper API
  - 本地 Whisper 模型 (whisper.cpp)

#### 组件设计

```go
// STT 引擎接口
type STTEngine interface {
    Transcribe(audioData []byte) (string, error)
}

// 阿里云 STT
type AliyunSTT struct {
    client *alibabacloud.Client
}

// Whisper STT
type WhisperSTT struct {
    apiKey string
}

// 本地 Whisper
type LocalWhisperSTT struct {
    modelPath string
}

// STT 管理器 (支持降级策略)
type STTManager struct {
    engines []STTEngine
    fallbackEnabled bool
}

func (m *STTManager) Transcribe(audio []byte) (string, error) {
    // 依次尝试各引擎,失败则降级
    for _, engine := range m.engines {
        text, err := engine.Transcribe(audio)
        if err == nil {
            return text, nil
        }
    }
    return "", errors.New("all STT engines failed")
}
```

#### 文本预处理

```go
type TextPreprocessor struct{}

func (p *TextPreprocessor) Normalize(text string) string {
    // 1. 去除多余空格
    // 2. 繁简转换
    // 3. 标点标准化
    // 4. 数字规范化 (如"一百" -> "100")
    return normalizedText
}
```

---

### 2.4 AI 理解引擎 (AI Understanding Engine)

#### 技术栈
- **语言**: Go
- **LLM**: 支持多种 LLM (ChatGPT, Claude, DeepSeek)
- **协议**: MCP (Model Context Protocol)

#### 核心设计

```go
// LLM 客户端接口
type LLMClient interface {
    Chat(ctx context.Context, messages []Message, tools []Tool) (*Response, error)
}

// 意图理解结果
type Intent struct {
    Name       string                 // 意图名称 (如 "navigate_map")
    Confidence float64                // 置信度
    Parameters map[string]interface{} // 参数
    ToolCalls  []ToolCall             // 需要调用的工具
}

// AI 理解引擎
type AIEngine struct {
    llmClient    LLMClient
    mcpClient    *MCPClient
    contextStore *ContextStore // 上下文存储
}

func (e *AIEngine) Understand(ctx context.Context, input string) (*Intent, error) {
    // 1. 获取上下文
    context := e.contextStore.GetContext()
    
    // 2. 构造消息
    messages := e.buildMessages(input, context)
    
    // 3. 获取可用工具列表
    tools := e.mcpClient.GetAvailableTools()
    
    // 4. 调用 LLM (支持 Function Calling)
    response, err := e.llmClient.Chat(ctx, messages, tools)
    if err != nil {
        return nil, err
    }
    
    // 5. 解析意图和参数
    intent := e.parseIntent(response)
    
    // 6. 更新上下文
    e.contextStore.UpdateContext(input, intent)
    
    return intent, nil
}
```

#### 上下文管理

```go
type ContextStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    SessionID   string
    Messages    []Message
    LastIntent  *Intent
    CreatedAt   time.Time
    LastActiveAt time.Time
}

func (c *ContextStore) GetContext() []Message {
    // 返回最近 N 轮对话历史
}

func (c *ContextStore) UpdateContext(input string, intent *Intent) {
    // 更新会话状态
}
```

---

### 2.5 MCP 客户端 (MCP Client)

#### 技术栈
- **语言**: Go
- **SDK**: github.com/modelcontextprotocol/sdk-go

#### 核心设计

```go
// MCP 客户端
type MCPClient struct {
    servers map[string]*MCPServer
    tools   map[string]*Tool
}

// MCP Server 连接
type MCPServer struct {
    Name       string
    Connection *mcp.Connection
    Status     ServerStatus
}

// 工具定义
type Tool struct {
    Name        string
    Description string
    InputSchema JSONSchema
    ServerName  string
}

// 启动所有 MCP Server
func (c *MCPClient) StartServers(configs []ServerConfig) error {
    for _, config := range configs {
        server, err := c.connectServer(config)
        if err != nil {
            log.Errorf("failed to connect server %s: %v", config.Name, err)
            continue
        }
        c.servers[config.Name] = server
        
        // 发现工具
        tools, err := server.ListTools()
        if err != nil {
            log.Errorf("failed to list tools from %s: %v", config.Name, err)
            continue
        }
        
        // 注册工具
        for _, tool := range tools {
            c.tools[tool.Name] = tool
        }
    }
    return nil
}

// 调用工具
func (c *MCPClient) CallTool(ctx context.Context, toolName string, params map[string]interface{}) (*ToolResult, error) {
    tool, exists := c.tools[toolName]
    if !exists {
        return nil, fmt.Errorf("tool %s not found", toolName)
    }
    
    // 验证参数
    if err := tool.ValidateParams(params); err != nil {
        return nil, err
    }
    
    // 获取对应的 server
    server := c.servers[tool.ServerName]
    
    // 调用工具
    result, err := server.CallTool(ctx, toolName, params)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}

// 获取可用工具列表 (供 LLM Function Calling 使用)
func (c *MCPClient) GetAvailableTools() []Tool {
    tools := make([]Tool, 0, len(c.tools))
    for _, tool := range c.tools {
        tools = append(tools, *tool)
    }
    return tools
}
```

#### 工具链编排

```go
// 工具链编排器 (支持多步骤操作)
type ToolOrchestrator struct {
    mcpClient *MCPClient
}

func (o *ToolOrchestrator) ExecuteChain(ctx context.Context, toolCalls []ToolCall) ([]ToolResult, error) {
    results := make([]ToolResult, 0, len(toolCalls))
    
    for _, call := range toolCalls {
        result, err := o.mcpClient.CallTool(ctx, call.Name, call.Parameters)
        if err != nil {
            // 错误处理: 继续执行还是中断?
            if call.Required {
                return results, err
            }
            log.Warnf("optional tool %s failed: %v", call.Name, err)
            continue
        }
        results = append(results, *result)
    }
    
    return results, nil
}
```

---

### 2.6 MCP 工具层 (MCP Tools)

#### 2.6.1 地图导航工具

**实现语言**: TypeScript/Node.js

```typescript
// 地图导航 MCP Server
import { Server } from '@modelcontextprotocol/sdk';

const server = new Server({
  name: 'map-navigation',
  version: '1.0.0',
});

server.setRequestHandler('tools/list', async () => ({
  tools: [
    {
      name: 'navigate_map',
      description: '打开地图应用并导航到指定地点',
      inputSchema: {
        type: 'object',
        properties: {
          origin: { type: 'string', description: '起点地址' },
          destination: { type: 'string', description: '目的地地址' },
          mapProvider: { 
            type: 'string', 
            enum: ['baidu', 'amap', 'google'],
            default: 'baidu' 
          },
          routeType: {
            type: 'string',
            enum: ['driving', 'walking', 'transit', 'cycling'],
            default: 'driving'
          }
        },
        required: ['destination']
      }
    }
  ]
}));

server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  
  if (name === 'navigate_map') {
    const url = buildMapURL(args);
    await openURL(url); // 使用 macOS open 命令或浏览器打开
    
    return {
      content: [
        {
          type: 'text',
          text: `已打开地图导航: ${args.origin || '当前位置'} → ${args.destination}`
        }
      ]
    };
  }
});
```

#### 2.6.2 天气查询工具

**实现语言**: Python

```python
from mcp.server import Server
from mcp.types import Tool, TextContent
import requests

app = Server("weather-query")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="query_weather",
            description="查询指定地点的天气信息",
            inputSchema={
                "type": "object",
                "properties": {
                    "location": {"type": "string", "description": "地点名称"},
                    "date": {"type": "string", "description": "日期 (today/tomorrow/日期)"},
                },
                "required": ["location"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "query_weather":
        location = arguments["location"]
        date = arguments.get("date", "today")
        
        # 调用天气 API (彩云天气/和风天气)
        weather_data = fetch_weather(location, date)
        
        return [
            TextContent(
                type="text",
                text=format_weather_info(weather_data)
            )
        ]
```

#### 2.6.3 音乐播放工具

**实现语言**: Go

```go
package main

import (
    "github.com/modelcontextprotocol/sdk-go/mcp"
)

func main() {
    server := mcp.NewServer("music-player", "1.0.0")
    
    server.HandleListTools(func() ([]mcp.Tool, error) {
        return []mcp.Tool{
            {
                Name:        "play_music",
                Description: "播放指定的音乐",
                InputSchema: map[string]interface{}{
                    "type": "object",
                    "properties": map[string]interface{}{
                        "song":   map[string]string{"type": "string", "description": "歌曲名称"},
                        "artist": map[string]string{"type": "string", "description": "歌手名称"},
                        "app":    map[string]interface{}{
                            "type": "string",
                            "enum": []string{"netease", "qq", "spotify", "apple"},
                            "default": "netease",
                        },
                    },
                    "required": []string{"song"},
                },
            },
        }, nil
    })
    
    server.HandleCallTool(func(name string, params map[string]interface{}) (*mcp.ToolResult, error) {
        if name == "play_music" {
            // 通过 AppleScript 或 API 控制音乐应用
            err := playMusicViaAppleScript(params)
            if err != nil {
                return nil, err
            }
            return &mcp.ToolResult{
                Content: []mcp.Content{
                    {Type: "text", Text: "正在播放音乐..."},
                },
            }, nil
        }
        return nil, fmt.Errorf("unknown tool: %s", name)
    })
    
    server.Start()
}
```

---

## 3. 数据模型设计

### 3.1 配置数据

```go
// 应用配置
type AppConfig struct {
    // 语音配置
    Voice struct {
        WakeWord       string   `json:"wake_word"`        // 唤醒词
        STTEngine      string   `json:"stt_engine"`       // 默认 STT 引擎
        STTFallback    bool     `json:"stt_fallback"`     // 是否启用降级
        VADSensitivity float64  `json:"vad_sensitivity"`  // VAD 灵敏度
    } `json:"voice"`
    
    // AI 配置
    AI struct {
        LLMProvider string `json:"llm_provider"` // ChatGPT/Claude/DeepSeek
        APIKey      string `json:"api_key"`
        Model       string `json:"model"`
        Temperature float64 `json:"temperature"`
    } `json:"ai"`
    
    // MCP 配置
    MCP struct {
        Servers []ServerConfig `json:"servers"`
    } `json:"mcp"`
    
    // UI 配置
    UI struct {
        HotKey      string `json:"hot_key"`       // 全局快捷键
        LaunchAtLogin bool `json:"launch_at_login"`
    } `json:"ui"`
}

// MCP Server 配置
type ServerConfig struct {
    Name    string                 `json:"name"`
    Command string                 `json:"command"` // 启动命令
    Args    []string               `json:"args"`
    Env     map[string]string      `json:"env"`
    Enabled bool                   `json:"enabled"`
}
```

### 3.2 持久化数据

```go
// 历史记录
type HistoryItem struct {
    ID        string    `db:"id"`
    SessionID string    `db:"session_id"`
    Input     string    `db:"input"`      // 用户输入
    Intent    string    `db:"intent"`     // 识别的意图
    ToolCalls string    `db:"tool_calls"` // JSON 序列化的工具调用
    Result    string    `db:"result"`     // 执行结果
    Success   bool      `db:"success"`
    CreatedAt time.Time `db:"created_at"`
}

// 使用统计
type UsageStats struct {
    Date       string `db:"date"`        // YYYY-MM-DD
    ToolName   string `db:"tool_name"`
    CallCount  int    `db:"call_count"`
    SuccessRate float64 `db:"success_rate"`
}
```

---

## 4. 通信协议设计

### 4.1 Swift ↔ Go 进程间通信

**方案**: gRPC

```protobuf
syntax = "proto3";

package wallecli;

// 核心服务
service WALLEService {
    // 处理文字输入
    rpc ProcessTextInput(TextInputRequest) returns (TextInputResponse);
    
    // 处理语音输入
    rpc ProcessVoiceInput(VoiceInputRequest) returns (VoiceInputResponse);
    
    // 获取历史记录
    rpc GetHistory(HistoryRequest) returns (HistoryResponse);
    
    // 获取配置
    rpc GetConfig(ConfigRequest) returns (ConfigResponse);
    
    // 更新配置
    rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);
}

message TextInputRequest {
    string input = 1;
    string session_id = 2;
}

message VoiceInputRequest {
    bytes audio_data = 1;
    string audio_format = 2; // wav, pcm
    string session_id = 3;
}

message TextInputResponse {
    string intent = 1;
    map<string, string> parameters = 2;
    repeated ToolCallResult tool_results = 3;
    string feedback_text = 4; // 反馈文本 (用于 TTS)
    bool success = 5;
}

message ToolCallResult {
    string tool_name = 1;
    bool success = 2;
    string result = 3;
    string error = 4;
}
```

### 4.2 MCP 协议通信

遵循 MCP 标准协议 (基于 JSON-RPC 2.0)

**示例: 工具调用请求**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "navigate_map",
    "arguments": {
      "origin": "上海七牛云",
      "destination": "虹桥机场",
      "mapProvider": "baidu",
      "routeType": "driving"
    }
  }
}
```

**示例: 工具调用响应**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "已打开百度地图导航: 上海七牛云 → 虹桥机场"
      }
    ],
    "isError": false
  }
}
```

---

## 5. 安全设计

### 5.1 权限管理

```go
// 危险操作列表
var DangerousTools = map[string]bool{
    "system_shutdown":  true,
    "system_restart":   true,
    "delete_file":      true,
    "execute_command":  true,
}

// 权限检查器
type PermissionChecker struct {
    userConfirmations map[string]bool // 用户已确认的操作
}

func (p *PermissionChecker) CheckPermission(toolName string) (bool, error) {
    if DangerousTools[toolName] {
        // 危险操作需要用户确认
        if !p.userConfirmations[toolName] {
            return false, errors.New("需要用户确认")
        }
    }
    return true, nil
}
```

### 5.2 敏感数据保护

```go
// 使用 macOS Keychain 存储敏感信息
type SecureStorage struct {
    keychain *Keychain
}

func (s *SecureStorage) StoreAPIKey(provider string, apiKey string) error {
    return s.keychain.Set(fmt.Sprintf("wallecli.apikey.%s", provider), apiKey)
}

func (s *SecureStorage) GetAPIKey(provider string) (string, error) {
    return s.keychain.Get(fmt.Sprintf("wallecli.apikey.%s", provider))
}
```

### 5.3 日志脱敏

```go
// 日志脱敏
type SensitiveFilter struct {
    patterns []string // 敏感信息正则
}

func (f *SensitiveFilter) Filter(log string) string {
    // 替换密码、Token、API Key 等敏感信息
    filtered := log
    for _, pattern := range f.patterns {
        re := regexp.MustCompile(pattern)
        filtered = re.ReplaceAllString(filtered, "***")
    }
    return filtered
}
```

---

## 6. 性能优化

### 6.1 启动优化

- **懒加载**: MCP Server 按需启动,而非全部预加载
- **并发启动**: 多个 MCP Server 并发启动
- **缓存**: 工具列表缓存,避免重复查询

```go
func (c *MCPClient) LazyLoadServer(serverName string) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if _, exists := c.servers[serverName]; exists {
        return nil // 已加载
    }
    
    config := c.configs[serverName]
    server, err := c.connectServer(config)
    if err != nil {
        return err
    }
    
    c.servers[serverName] = server
    return nil
}
```

### 6.2 内存优化

- **音频流处理**: 使用流式处理,避免大块内存分配
- **上下文管理**: 限制上下文历史长度 (如最多保留 10 轮对话)
- **定期清理**: 定期清理过期的会话数据

### 6.3 响应优化

- **并行调用**: 独立工具并行调用
- **超时控制**: 每个工具调用设置超时
- **降级策略**: 工具失败时快速降级

---

## 7. 可扩展性设计

### 7.1 插件系统

支持第三方开发 MCP Server 插件

```yaml
# 插件市场配置示例
plugins:
  - name: weather-extended
    author: community
    version: 1.2.0
    description: 增强版天气查询工具
    install_command: npm install -g @wallecli/weather-extended
    server_config:
      command: weather-extended-server
      args: []
```

### 7.2 配置热更新

支持无需重启的配置更新

```go
type ConfigWatcher struct {
    configPath string
    onChange   func(*AppConfig)
}

func (w *ConfigWatcher) Watch() {
    // 监听配置文件变化
    // 变化时重新加载并触发 onChange 回调
}
```

---

## 8. 测试策略

### 8.1 单元测试

- **覆盖率目标**: > 80%
- **Mock**: 使用 Mock 隔离外部依赖 (LLM API, MCP Server)

### 8.2 集成测试

```go
func TestEndToEndFlow(t *testing.T) {
    // 启动测试用 MCP Server
    testServer := startTestMCPServer()
    defer testServer.Stop()
    
    // 创建 AI 引擎 (使用 Mock LLM)
    engine := NewAIEngine(mockLLM, testMCPClient)
    
    // 测试输入
    input := "查看明天上海的天气"
    
    // 执行
    intent, err := engine.Understand(context.Background(), input)
    require.NoError(t, err)
    
    // 验证
    assert.Equal(t, "query_weather", intent.Name)
    assert.Equal(t, "上海", intent.Parameters["location"])
    assert.Equal(t, "tomorrow", intent.Parameters["date"])
}
```

### 8.3 性能测试

- **启动时间**: < 2s
- **端到端延迟**: 文字输入 < 5s, 语音输入 < 10s
- **内存占用**: 空闲 < 200MB, 运行 < 500MB

---

## 9. 部署架构

### 9.1 应用结构

```
WALLE.app/
├── Contents/
│   ├── MacOS/
│   │   ├── WALLE              # Swift 可执行文件 (UI + 语音)
│   │   └── walle-core         # Go 可执行文件 (核心处理)
│   ├── Resources/
│   │   ├── models/
│   │   │   └── wakeword.ppn   # 唤醒词模型
│   │   ├── configs/
│   │   │   └── default.json   # 默认配置
│   │   └── mcp-servers/       # 内置 MCP Server
│   │       ├── map-navigation/
│   │       ├── weather-query/
│   │       └── music-player/
│   └── Info.plist
```

### 9.2 进程管理

- **主进程**: Swift 应用 (UI)
- **子进程**: Go 核心服务 (gRPC Server)
- **MCP Server 进程**: 按需启动的独立进程

```swift
// Swift 中启动 Go 核心服务
class CoreServiceManager {
    func startCoreService() {
        let corePath = Bundle.main.path(forResource: "walle-core", ofType: nil)!
        let process = Process()
        process.executableURL = URL(fileURLWithPath: corePath)
        process.arguments = ["--port", "50051"]
        try? process.run()
    }
}
```

---

## 10. 监控与日志

### 10.1 日志分级

```go
// 使用结构化日志 (如 zap)
logger := zap.NewProduction()

logger.Info("user input received",
    zap.String("input", userInput),
    zap.String("session_id", sessionID),
)

logger.Error("tool call failed",
    zap.String("tool", toolName),
    zap.Error(err),
)
```

### 10.2 性能指标采集

```go
// 记录关键操作的耗时
type Metrics struct {
    STTLatency     prometheus.Histogram
    AILatency      prometheus.Histogram
    ToolCallLatency prometheus.Histogram
}

func (m *Metrics) RecordSTTLatency(duration time.Duration) {
    m.STTLatency.Observe(duration.Seconds())
}
```

---

## 11. 总结

本架构设计文档详细描述了 WALL-E 系统的技术架构,包括:

1. **分层架构**: 用户交互层 → 核心处理层 → MCP 工具层 → 系统能力层
2. **核心模块**: 语音输入、文字输入、STT、AI 理解、MCP 客户端
3. **MCP 工具**: 地图导航、天气查询、音乐播放等可扩展工具
4. **通信协议**: gRPC (进程间) + MCP (工具调用)
5. **安全设计**: 权限管理、数据加密、日志脱敏
6. **性能优化**: 懒加载、并发、缓存
7. **可扩展性**: 插件系统、配置热更新

该架构支持快速迭代,可从 MVP 逐步演进到完整产品。
