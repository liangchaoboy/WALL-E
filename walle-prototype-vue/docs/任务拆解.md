# 任务拆解与实施计划
# WALL-E: AI 驱动的桌面操作系统代理

---

## 📑 文档信息

| 项目 | 内容 |
|------|------|
| **项目名称** | WALL-E (AI Copilot for PC) |
| **版本** | v1.0 |
| **文档类型** | 任务拆解与实施计划 |
| **创建日期** | 2025-10-26 |
| **基于** | PRD v3.0 + 架构设计文档 v1.0 |

---

## 1. 任务拆解概览

> **注**: 本文档包含两部分:
> - **第一部分**: 当前已完成的任务 (tao 分支实现)
> - **第二部分**: 规划中的任务 (未来 macOS 原生版本)

### 1.0 当前实现状态 (tao 分支)

#### 已完成的里程碑

**M0: 快速原型验证** ✅ 已完成
- **时间**: 2025-10 月
- **架构**: Vue + Go + FastGPT + MCP
- **核心功能**: 地图导航语音助手

#### 已完成的任务清单

| 任务 ID | 任务名称 | 状态 | 说明 |
|---------|---------|------|------|
| T0.1 | 前端 Vue 项目初始化 | ✅ 完成 | voice-assistant/ 目录 |
| T0.2 | Web Speech API 集成 | ✅ 完成 | 浏览器原生语音识别 |
| T0.3 | 语音界面实现 | ✅ 完成 | App.vue 主组件 |
| T0.4 | 调试日志面板 | ✅ 完成 | 实时对话显示 |
| T0.5 | Go 后端服务 (WALL-E-SERVE) | ✅ 完成 | Gin HTTP 服务器 |
| T0.6 | FastGPT 客户端集成 | ✅ 完成 | fast/fastgpt.go |
| T0.7 | 响应模式解析 | ✅ 完成 | JSON/纯文本双模式 |
| T0.8 | MCP 服务器 (WALL-E-MCP) | ✅ 完成 | 地图导航工具 |
| T0.9 | navigate_map 工具实现 | ✅ 完成 | 支持百度/高德/谷歌 |
| T0.10 | 地图提供商适配 | ✅ 完成 | mapprovider/provider.go |
| T0.11 | URL 生成逻辑 | ✅ 完成 | 多地图服务支持 |
| T0.12 | Makefile 构建脚本 | ✅ 完成 | 一键启动和运行 |
| T0.13 | 端到端测试 | ✅ 完成 | 语音导航全流程 |

#### 当前技术栈总结

| 层级 | 技术选型 | 说明 |
|------|---------|------|
| **前端** | Vue.js 2.x | Web 应用 |
| **语音识别** | Web Speech API | 浏览器原生 |
| **后端服务** | Go + Gin | HTTP API 服务器 |
| **AI 平台** | FastGPT + QWen | 云端 AI 理解 |
| **MCP 工具** | Go + mcp-go SDK | 地图导航工具 |
| **部署** | 本地运行 | 三个服务独立部署 |

#### 当前架构优势

| 优势 | 说明 |
|------|------|
| ✅ 快速验证 | Web 技术栈,开发速度快 |
| ✅ 跨平台 | 浏览器即可运行 |
| ✅ 低成本 | 无需本地 LLM,使用云端 FastGPT |
| ✅ 易扩展 | MCP 架构支持添加新工具 |
| ✅ 易部署 | 无需打包,直接运行 |

#### 当前架构限制

| 限制 | 影响 | 未来改进 |
|------|------|---------|
| ⚠️ 依赖浏览器 | 需要打开浏览器使用 | 开发原生 macOS 应用 |
| ⚠️ 无唤醒词 | 需要手动点击"开始聆听" | 集成 Porcupine 本地唤醒 |
| ⚠️ 依赖云端 AI | 需要网络和 API Key | 支持本地 LLM 模型 |
| ⚠️ 无系统集成 | 不能控制系统/应用 | 开发系统控制工具 |

---

### 1.1 总体时间规划 (未来版本)

| 阶段 | 时间 | 核心目标 | 交付物 |
|------|------|----------|--------|
| **阶段一: MVP** | 2-3 周 | 验证技术可行性 | 地图导航功能 Demo |
| **阶段二: 功能扩展** | 2-3 周 | 增加实用工具 | 4 种操作类型 |
| **阶段三: 高级能力** | 2-3 周 | 复杂操作支持 | 浏览器控制 + 系统控制 |
| **阶段四: 优化发布** | 1-2 周 | 性能优化 + 发布 | V1.0 正式版本 |

**总开发周期**: 8-10 周 (约 2-2.5 个月)

---

## 2. 阶段一: MVP (2-3 周)

### 目标
验证核心技术可行性,实现基础地图导航功能。

---

### 任务 1.1: 项目初始化

**优先级**: P0  
**预计时间**: 1-2 天  
**负责模块**: 全栈

#### 子任务

1. **创建项目结构**
   ```bash
   walle/
   ├── macos-app/           # Swift macOS 应用
   │   ├── WALLE/
   │   │   ├── App/         # 应用入口
   │   │   ├── UI/          # UI 组件
   │   │   └── Services/    # Swift 服务层
   │   └── WALLE.xcodeproj
   ├── core-service/        # Go 核心服务
   │   ├── cmd/
   │   │   └── walle-core/  # 主程序入口
   │   ├── internal/
   │   │   ├── stt/         # STT 模块
   │   │   ├── ai/          # AI 理解引擎
   │   │   ├── mcp/         # MCP 客户端
   │   │   └── config/      # 配置管理
   │   └── go.mod
   ├── mcp-tools/           # MCP 工具集合
   │   ├── map-navigation/  # 地图导航工具
   │   ├── weather-query/   # 天气查询工具
   │   └── music-player/    # 音乐播放工具
   └── docs/                # 文档
   ```

2. **配置开发环境**
   - 安装 Xcode (Swift 开发)
   - 安装 Go 1.21+
   - 安装 Node.js 18+ (MCP 工具开发)
   - 安装依赖包管理工具 (CocoaPods/SPM, Go Modules, npm)

3. **初始化 Git 仓库**
   - 创建 `.gitignore`
   - 设置分支策略: `main`, `develop`, `feature/*`

4. **配置 CI/CD**
   - GitHub Actions 配置文件
   - 自动化测试流程
   - 自动化构建流程

**验收标准**:
- ✅ 项目结构创建完成
- ✅ 开发环境配置完成
- ✅ 可以成功编译 Swift 和 Go 项目

---

### 任务 1.2: Swift macOS 应用框架

**优先级**: P0  
**预计时间**: 3-4 天  
**负责模块**: macOS App (Swift)

#### 子任务

1. **创建系统托盘应用**
   ```swift
   // AppDelegate.swift
   class AppDelegate: NSObject, NSApplicationDelegate {
       var statusItem: NSStatusItem?
       
       func applicationDidFinishLaunching(_ notification: Notification) {
           setupStatusBar()
       }
       
       func setupStatusBar() {
           statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
           statusItem?.button?.image = NSImage(systemSymbolName: "sparkles", accessibilityDescription: "WALL-E")
       }
   }
   ```

2. **实现文字输入界面 (SwiftUI)**
   ```swift
   struct InputWindow: View {
       @State private var inputText = ""
       
       var body: some View {
           VStack(spacing: 16) {
               TextField("输入指令...", text: $inputText)
                   .textFieldStyle(RoundedBorderTextFieldStyle())
                   .onSubmit {
                       handleInput(inputText)
                   }
               
               Button("发送") {
                   handleInput(inputText)
               }
           }
           .padding()
           .frame(width: 400, height: 100)
       }
       
       func handleInput(_ text: String) {
           // TODO: 调用 Go 核心服务
       }
   }
   ```

3. **全局快捷键监听**
   ```swift
   import Carbon
   
   class HotKeyManager {
       func registerHotKey(key: UInt32, modifiers: UInt32, handler: @escaping () -> Void) {
           // 使用 Carbon API 注册全局快捷键
       }
   }
   ```

4. **权限申请界面**
   - 麦克风权限申请
   - 辅助功能权限申请

**验收标准**:
- ✅ 系统托盘图标显示
- ✅ 点击图标打开输入窗口
- ✅ 全局快捷键 Cmd+Space 唤醒
- ✅ 文字输入框可以接收输入

---

### 任务 1.3: 语音输入模块 (基础版)

**优先级**: P0  
**预计时间**: 2-3 天  
**负责模块**: macOS App (Swift)

#### 子任务

1. **集成 Porcupine 唤醒词引擎**
   ```swift
   import Porcupine
   
   class WakeWordDetector {
       private var porcupine: Porcupine?
       
       func start() throws {
           porcupine = try Porcupine(keyword: .xiaoqi) // 小七小七
           // 开始监听麦克风
       }
       
       func onWakeWordDetected(handler: @escaping () -> Void) {
           // 检测到唤醒词时的回调
       }
   }
   ```

2. **实现音频采集**
   ```swift
   import AVFoundation
   
   class AudioCapture {
       private let audioEngine = AVAudioEngine()
       
       func startRecording() {
           let inputNode = audioEngine.inputNode
           let recordingFormat = inputNode.outputFormat(forBus: 0)
           
           inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in
               self.processAudioBuffer(buffer)
           }
           
           try? audioEngine.start()
       }
       
       func stopRecording() {
           audioEngine.stop()
           audioEngine.inputNode.removeTap(onBus: 0)
       }
   }
   ```

3. **实现简单的 VAD (语音活动检测)**
   ```swift
   class SimpleVAD {
       func isSpeechDetected(buffer: AVAudioPCMBuffer) -> Bool {
           // 简单的能量检测算法
           let channelData = buffer.floatChannelData![0]
           let frameLength = Int(buffer.frameLength)
           
           var sum: Float = 0
           for i in 0..<frameLength {
               sum += abs(channelData[i])
           }
           
           let average = sum / Float(frameLength)
           return average > 0.01 // 阈值
       }
   }
   ```

**验收标准**:
- ✅ 说"小七小七"可以唤醒系统
- ✅ 唤醒后开始录音
- ✅ 检测到语音结束后停止录音

---

### 任务 1.4: Go 核心服务 - STT 集成

**优先级**: P0  
**预计时间**: 2-3 天  
**负责模块**: Core Service (Go)

#### 子任务

1. **创建 gRPC 服务**
   ```go
   // proto/walle.proto
   syntax = "proto3";
   
   service WALLEService {
       rpc ProcessTextInput(TextInputRequest) returns (TextInputResponse);
       rpc ProcessVoiceInput(VoiceInputRequest) returns (VoiceInputResponse);
   }
   ```

2. **集成阿里云 STT**
   ```go
   package stt
   
   import (
       alibabacloud "github.com/alibabacloud-go/darabonba-openapi/client"
   )
   
   type AliyunSTT struct {
       client *alibabacloud.Client
       appKey string
   }
   
   func (s *AliyunSTT) Transcribe(audioData []byte) (string, error) {
       // 调用阿里云语音识别 API
       // 返回识别的文本
   }
   ```

3. **实现 STT 管理器 (支持降级)**
   ```go
   type STTManager struct {
       engines []STTEngine
   }
   
   func (m *STTManager) Transcribe(audio []byte) (string, error) {
       for _, engine := range m.engines {
           text, err := engine.Transcribe(audio)
           if err == nil {
               return text, nil
           }
           log.Warnf("STT engine failed, trying fallback: %v", err)
       }
       return "", errors.New("all STT engines failed")
   }
   ```

**验收标准**:
- ✅ gRPC 服务可以启动
- ✅ 接收音频数据并调用 STT API
- ✅ 返回识别的文本

---

### 任务 1.5: AI 理解引擎 (基础版)

**优先级**: P0  
**预计时间**: 2-3 天  
**负责模块**: Core Service (Go)

#### 子任务

1. **集成 ChatGPT API**
   ```go
   package ai
   
   import "github.com/sashabaranov/go-openai"
   
   type ChatGPTClient struct {
       client *openai.Client
   }
   
   func (c *ChatGPTClient) Chat(ctx context.Context, messages []Message, tools []Tool) (*Response, error) {
       req := openai.ChatCompletionRequest{
           Model:    openai.GPT4,
           Messages: convertMessages(messages),
           Tools:    convertTools(tools),
       }
       
       resp, err := c.client.CreateChatCompletion(ctx, req)
       if err != nil {
           return nil, err
       }
       
       return parseResponse(resp), nil
   }
   ```

2. **实现意图识别**
   ```go
   type AIEngine struct {
       llmClient LLMClient
       mcpClient *MCPClient
   }
   
   func (e *AIEngine) Understand(ctx context.Context, input string) (*Intent, error) {
       // 1. 获取可用工具
       tools := e.mcpClient.GetAvailableTools()
       
       // 2. 构造 Prompt
       systemPrompt := "你是一个智能助手,帮助用户操作电脑。根据用户输入,选择合适的工具并提取参数。"
       
       messages := []Message{
           {Role: "system", Content: systemPrompt},
           {Role: "user", Content: input},
       }
       
       // 3. 调用 LLM
       response, err := e.llmClient.Chat(ctx, messages, tools)
       if err != nil {
           return nil, err
       }
       
       // 4. 解析工具调用
       return parseIntent(response), nil
   }
   ```

**验收标准**:
- ✅ 接收用户输入文本
- ✅ 调用 ChatGPT API 进行意图识别
- ✅ 返回结构化的意图和参数

---

### 任务 1.6: MCP 客户端基础实现

**优先级**: P0  
**预计时间**: 2-3 天  
**负责模块**: Core Service (Go)

#### 子任务

1. **实现 MCP 客户端**
   ```go
   package mcp
   
   import "github.com/modelcontextprotocol/sdk-go/mcp"
   
   type MCPClient struct {
       servers map[string]*MCPServer
       tools   map[string]*Tool
   }
   
   func (c *MCPClient) ConnectServer(config ServerConfig) error {
       conn, err := mcp.NewStdioConnection(config.Command, config.Args, config.Env)
       if err != nil {
           return err
       }
       
       server := &MCPServer{
           Name:       config.Name,
           Connection: conn,
       }
       
       // 发现工具
       tools, err := server.ListTools()
       if err != nil {
           return err
       }
       
       c.servers[config.Name] = server
       for _, tool := range tools {
           c.tools[tool.Name] = tool
       }
       
       return nil
   }
   
   func (c *MCPClient) CallTool(ctx context.Context, toolName string, params map[string]interface{}) (*ToolResult, error) {
       tool := c.tools[toolName]
       server := c.servers[tool.ServerName]
       
       return server.CallTool(ctx, toolName, params)
   }
   ```

**验收标准**:
- ✅ 可以连接 MCP Server
- ✅ 可以发现工具列表
- ✅ 可以调用工具并获取结果

---

### 任务 1.7: 地图导航 MCP 工具

**优先级**: P0  
**预计时间**: 1-2 天  
**负责模块**: MCP Tools (TypeScript)

#### 子任务

1. **创建 MCP Server**
   ```typescript
   // mcp-tools/map-navigation/src/index.ts
   import { Server } from '@modelcontextprotocol/sdk';
   import { exec } from 'child_process';
   
   const server = new Server({
     name: 'map-navigation',
     version: '1.0.0',
   });
   
   server.setRequestHandler('tools/list', async () => ({
     tools: [
       {
         name: 'navigate_map',
         description: '打开地图应用并导航到指定地点',
         inputSchema: {
           type: 'object',
           properties: {
             origin: { type: 'string', description: '起点地址' },
             destination: { type: 'string', description: '目的地地址' },
             mapProvider: { 
               type: 'string', 
               enum: ['baidu', 'amap', 'google'],
               default: 'baidu' 
             },
           },
           required: ['destination']
         }
       }
     ]
   }));
   
   server.setRequestHandler('tools/call', async (request) => {
     const { name, arguments: args } = request.params;
     
     if (name === 'navigate_map') {
       const url = buildMapURL(args);
       
       // 使用 macOS open 命令打开 URL
       exec(`open "${url}"`, (error) => {
         if (error) {
           throw new Error(`Failed to open map: ${error.message}`);
         }
       });
       
       return {
         content: [
           {
             type: 'text',
             text: `已打开地图导航: ${args.origin || '当前位置'} → ${args.destination}`
           }
         ]
       };
     }
   });
   
   function buildMapURL(args: any): string {
     const { origin, destination, mapProvider } = args;
     
     switch (mapProvider) {
       case 'baidu':
         return `https://map.baidu.com/?from=${origin}&to=${destination}`;
       case 'amap':
         return `https://uri.amap.com/navigation?from=${origin}&to=${destination}`;
       case 'google':
         return `https://maps.google.com/?saddr=${origin}&daddr=${destination}`;
       default:
         return `https://map.baidu.com/?to=${destination}`;
     }
   }
   
   server.start();
   ```

2. **配置 package.json**
   ```json
   {
     "name": "@walle/map-navigation",
     "version": "1.0.0",
     "main": "dist/index.js",
     "bin": {
       "map-navigation-server": "./dist/index.js"
     },
     "scripts": {
       "build": "tsc",
       "start": "node dist/index.js"
     },
     "dependencies": {
       "@modelcontextprotocol/sdk": "^1.0.0"
     }
   }
   ```

**验收标准**:
- ✅ MCP Server 可以启动
- ✅ 可以正确响应 tools/list 请求
- ✅ 调用 navigate_map 可以打开地图应用

---

### 任务 1.8: 端到端集成测试

**优先级**: P0  
**预计时间**: 1-2 天  
**负责模块**: 全栈

#### 测试场景

1. **文字输入流程**
   - 用户输入: "从上海七牛云到虹桥机场"
   - 预期结果: 打开地图应用,显示导航路线

2. **语音输入流程**
   - 用户说: "小七小七,从上海七牛云到虹桥机场"
   - 预期结果: 打开地图应用,显示导航路线

**验收标准**:
- ✅ 文字输入流程正常工作
- ✅ 语音输入流程正常工作 (可选,如时间不够可延后)
- ✅ 端到端延迟 < 10 秒

---

## 3. 阶段二: 功能扩展 (2-3 周)

### 目标
增加更多实用工具,完善用户体验。

---

### 任务 2.1: 天气查询工具

**优先级**: P0  
**预计时间**: 2-3 天  
**负责模块**: MCP Tools (Python)

#### 子任务

1. **创建天气查询 MCP Server**
   ```python
   # mcp-tools/weather-query/server.py
   from mcp.server import Server
   from mcp.types import Tool, TextContent
   import requests
   
   app = Server("weather-query")
   
   @app.list_tools()
   async def list_tools() -> list[Tool]:
       return [
           Tool(
               name="query_weather",
               description="查询指定地点的天气信息",
               inputSchema={
                   "type": "object",
                   "properties": {
                       "location": {"type": "string", "description": "地点名称"},
                       "date": {"type": "string", "description": "日期 (today/tomorrow)"},
                   },
                   "required": ["location"]
               }
           )
       ]
   
   @app.call_tool()
   async def call_tool(name: str, arguments: dict):
       if name == "query_weather":
           location = arguments["location"]
           date = arguments.get("date", "today")
           
           # 调用彩云天气 API
           weather_data = fetch_weather_from_caiyun(location, date)
           
           return [
               TextContent(
                   type="text",
                   text=format_weather(weather_data)
               )
           ]
   
   def fetch_weather_from_caiyun(location: str, date: str):
       # TODO: 调用彩云天气 API
       pass
   
   def format_weather(data):
       return f"温度: {data['temp']}°C, 天气: {data['desc']}, 降雨概率: {data['rain_prob']}%"
   ```

2. **集成到 MCP 客户端**
   - 添加配置到 `config.json`
   - 测试工具调用

**验收标准**:
- ✅ 天气查询工具可以正常工作
- ✅ 用户输入"查看明天上海的天气"可以得到正确结果

---

### 任务 2.2: 音乐播放工具

**优先级**: P1  
**预计时间**: 2-3 天  
**负责模块**: MCP Tools (Go)

#### 子任务

1. **创建音乐播放 MCP Server**
   ```go
   // mcp-tools/music-player/main.go
   package main
   
   import (
       "github.com/modelcontextprotocol/sdk-go/mcp"
       "os/exec"
   )
   
   func main() {
       server := mcp.NewServer("music-player", "1.0.0")
       
       server.HandleListTools(func() ([]mcp.Tool, error) {
           return []mcp.Tool{
               {
                   Name:        "play_music",
                   Description: "播放指定的音乐",
                   InputSchema: map[string]interface{}{
                       "type": "object",
                       "properties": map[string]interface{}{
                           "song":   map[string]string{"type": "string"},
                           "artist": map[string]string{"type": "string"},
                       },
                       "required": []string{"song"},
                   },
               },
           }, nil
       })
       
       server.HandleCallTool(func(name string, params map[string]interface{}) (*mcp.ToolResult, error) {
           if name == "play_music" {
               song := params["song"].(string)
               artist := params["artist"].(string)
               
               // 使用 AppleScript 控制 Music.app
               script := fmt.Sprintf(`
                   tell application "Music"
                       play (first track whose name contains "%s" and artist contains "%s")
                   end tell
               `, song, artist)
               
               cmd := exec.Command("osascript", "-e", script)
               err := cmd.Run()
               if err != nil {
                   return nil, err
               }
               
               return &mcp.ToolResult{
                   Content: []mcp.Content{
                       {Type: "text", Text: fmt.Sprintf("正在播放: %s - %s", artist, song)},
                   },
               }, nil
           }
           return nil, fmt.Errorf("unknown tool: %s", name)
       })
       
       server.Start()
   }
   ```

**验收标准**:
- ✅ 音乐播放工具可以正常工作
- ✅ 用户输入"播放周杰伦的晴天"可以打开音乐应用并播放

---

### 任务 2.3: 应用启动工具

**优先级**: P1  
**预计时间**: 1-2 天  
**负责模块**: MCP Tools (Shell)

#### 子任务

1. **创建应用启动 MCP Server**
   ```bash
   # mcp-tools/app-launcher/launcher.sh
   #!/bin/bash
   
   case "$1" in
       safari)
           open -a "Safari"
           ;;
       chrome)
           open -a "Google Chrome"
           ;;
       vscode)
           open -a "Visual Studio Code"
           ;;
       *)
           open -a "$1"
           ;;
   esac
   ```

2. **封装为 MCP Server** (使用 Node.js 包装)

**验收标准**:
- ✅ 可以启动常见应用 (Safari, Chrome, VSCode 等)
- ✅ 用户输入"打开 Safari"可以启动 Safari

---

### 任务 2.4: 多轮对话支持

**优先级**: P1  
**预计时间**: 2-3 天  
**负责模块**: Core Service (Go)

#### 子任务

1. **实现上下文管理**
   ```go
   type ContextStore struct {
       mu       sync.RWMutex
       sessions map[string]*Session
   }
   
   type Session struct {
       SessionID   string
       Messages    []Message
       LastIntent  *Intent
       CreatedAt   time.Time
   }
   
   func (c *ContextStore) GetContext(sessionID string) []Message {
       c.mu.RLock()
       defer c.mu.RUnlock()
       
       session := c.sessions[sessionID]
       if session == nil {
           return []Message{}
       }
       
       // 返回最近 5 轮对话
       if len(session.Messages) <= 10 {
           return session.Messages
       }
       return session.Messages[len(session.Messages)-10:]
   }
   ```

2. **更新 AI 引擎以支持上下文**
   ```go
   func (e *AIEngine) Understand(ctx context.Context, sessionID string, input string) (*Intent, error) {
       // 1. 获取历史上下文
       contextMessages := e.contextStore.GetContext(sessionID)
       
       // 2. 添加当前输入
       messages := append(contextMessages, Message{
           Role:    "user",
           Content: input,
       })
       
       // 3. 调用 LLM
       response, err := e.llmClient.Chat(ctx, messages, tools)
       
       // 4. 更新上下文
       e.contextStore.UpdateContext(sessionID, messages, response)
       
       return parseIntent(response), nil
   }
   ```

**验收标准**:
- ✅ 支持简单的多轮对话
- ✅ 例如: "查看上海天气" → "明天呢?" (可以理解"明天"指明天上海的天气)

---

### 任务 2.5: 历史记录功能

**优先级**: P2  
**预计时间**: 2-3 天  
**负责模块**: macOS App + Core Service

#### 子任务

1. **数据库设计 (SQLite)**
   ```sql
   CREATE TABLE history (
       id TEXT PRIMARY KEY,
       session_id TEXT,
       input TEXT,
       intent TEXT,
       tool_calls TEXT,
       result TEXT,
       success BOOLEAN,
       created_at TIMESTAMP
   );
   ```

2. **历史记录 UI**
   ```swift
   struct HistoryView: View {
       @State var historyItems: [HistoryItem] = []
       
       var body: some View {
           List(historyItems) { item in
               VStack(alignment: .leading) {
                   Text(item.input)
                       .font(.headline)
                   Text(item.result)
                       .font(.subheadline)
                       .foregroundColor(.gray)
               }
           }
       }
   }
   ```

**验收标准**:
- ✅ 所有操作记录到数据库
- ✅ 用户可以查看历史记录

---

## 4. 阶段三: 高级能力 (2-3 周)

### 目标
实现复杂操作,提升智能化水平。

---

### 任务 3.1: 浏览器控制工具

**优先级**: P1  
**预计时间**: 4-5 天  
**负责模块**: MCP Tools (TypeScript + Playwright)

#### 子任务

1. **创建浏览器控制 MCP Server**
   ```typescript
   // mcp-tools/browser-control/src/index.ts
   import { Server } from '@modelcontextprotocol/sdk';
   import { chromium, Browser, Page } from 'playwright';
   
   let browser: Browser | null = null;
   let page: Page | null = null;
   
   const server = new Server({
     name: 'browser-control',
     version: '1.0.0',
   });
   
   server.setRequestHandler('tools/list', async () => ({
     tools: [
       {
         name: 'open_url',
         description: '打开指定的网页',
         inputSchema: {
           type: 'object',
           properties: {
             url: { type: 'string', description: '网页 URL' },
           },
           required: ['url']
         }
       },
       {
         name: 'fill_form',
         description: '填充网页表单',
         inputSchema: {
           type: 'object',
           properties: {
             selector: { type: 'string', description: 'CSS 选择器' },
             value: { type: 'string', description: '填充的值' },
           },
           required: ['selector', 'value']
         }
       },
       {
         name: 'click_element',
         description: '点击网页元素',
         inputSchema: {
           type: 'object',
           properties: {
             selector: { type: 'string', description: 'CSS 选择器' },
           },
           required: ['selector']
         }
       },
     ]
   }));
   
   server.setRequestHandler('tools/call', async (request) => {
     const { name, arguments: args } = request.params;
     
     // 确保浏览器已启动
     if (!browser) {
       browser = await chromium.launch({ headless: false });
       page = await browser.newPage();
     }
     
     switch (name) {
       case 'open_url':
         await page!.goto(args.url);
         return { content: [{ type: 'text', text: `已打开 ${args.url}` }] };
       
       case 'fill_form':
         await page!.fill(args.selector, args.value);
         return { content: [{ type: 'text', text: `已填充表单` }] };
       
       case 'click_element':
         await page!.click(args.selector);
         return { content: [{ type: 'text', text: `已点击元素` }] };
     }
   });
   ```

2. **实现自动登录场景**
   - 工具链编排: open_url → fill_form (用户名) → fill_form (密码) → click_element (登录按钮)

**验收标准**:
- ✅ 可以打开网页
- ✅ 可以填充表单
- ✅ 可以点击按钮
- ✅ 用户输入"打开七牛云官网并登录"可以自动完成登录流程

---

### 任务 3.2: 系统控制工具

**优先级**: P2  
**预计时间**: 3-4 天  
**负责模块**: MCP Tools (Shell/AppleScript)

#### 子任务

1. **创建系统控制 MCP Server**
   ```typescript
   // mcp-tools/system-control/src/index.ts
   import { Server } from '@modelcontextprotocol/sdk';
   import { exec } from 'child_process';
   import { promisify } from 'util';
   
   const execAsync = promisify(exec);
   
   const server = new Server({
     name: 'system-control',
     version: '1.0.0',
   });
   
   server.setRequestHandler('tools/list', async () => ({
     tools: [
       {
         name: 'set_volume',
         description: '设置系统音量',
         inputSchema: {
           type: 'object',
           properties: {
             volume: { type: 'number', description: '音量 (0-100)', minimum: 0, maximum: 100 },
           },
           required: ['volume']
         }
       },
       {
         name: 'set_brightness',
         description: '设置屏幕亮度',
         inputSchema: {
           type: 'object',
           properties: {
             brightness: { type: 'number', description: '亮度 (0-100)', minimum: 0, maximum: 100 },
           },
           required: ['brightness']
         }
       },
       {
         name: 'system_shutdown',
         description: '关机 (需要用户确认)',
         inputSchema: {
           type: 'object',
           properties: {
             delay: { type: 'number', description: '延迟时间(分钟)', default: 0 },
           }
         }
       },
     ]
   }));
   
   server.setRequestHandler('tools/call', async (request) => {
     const { name, arguments: args } = request.params;
     
     switch (name) {
       case 'set_volume':
         await execAsync(`osascript -e "set volume output volume ${args.volume}"`);
         return { content: [{ type: 'text', text: `音量已设置为 ${args.volume}%` }] };
       
       case 'set_brightness':
         // 使用 brightness 命令行工具
         await execAsync(`brightness ${args.brightness / 100}`);
         return { content: [{ type: 'text', text: `亮度已设置为 ${args.brightness}%` }] };
       
       case 'system_shutdown':
         // 危险操作,需要用户确认
         const delay = args.delay || 0;
         await execAsync(`sudo shutdown -h +${delay}`);
         return { content: [{ type: 'text', text: `系统将在 ${delay} 分钟后关机` }] };
     }
   });
   ```

2. **实现安全确认机制**
   - 危险操作需要用户弹窗确认
   - 在 Swift 中实现确认对话框

**验收标准**:
- ✅ 可以设置音量
- ✅ 可以设置亮度
- ✅ 关机操作有确认对话框

---

### 任务 3.3: 工具链编排

**优先级**: P1  
**预计时间**: 2-3 天  
**负责模块**: Core Service (Go)

#### 子任务

1. **实现工具链编排器**
   ```go
   type ToolOrchestrator struct {
       mcpClient *MCPClient
   }
   
   func (o *ToolOrchestrator) ExecuteChain(ctx context.Context, toolCalls []ToolCall) ([]ToolResult, error) {
       results := make([]ToolResult, 0, len(toolCalls))
       
       for i, call := range toolCalls {
           log.Infof("Executing tool %d/%d: %s", i+1, len(toolCalls), call.Name)
           
           result, err := o.mcpClient.CallTool(ctx, call.Name, call.Parameters)
           if err != nil {
               if call.Required {
                   return results, fmt.Errorf("required tool %s failed: %w", call.Name, err)
               }
               log.Warnf("Optional tool %s failed: %v", call.Name, err)
               continue
           }
           
           results = append(results, *result)
       }
       
       return results, nil
   }
   ```

2. **AI 引擎支持多步骤操作**
   - LLM 返回多个 ToolCall
   - 按顺序执行

**验收标准**:
- ✅ 支持多步骤操作
- ✅ 例如: "打开七牛云官网并登录" = open_url + fill_form + click_element

---

## 5. 阶段四: 优化与发布 (1-2 周)

### 目标
性能优化、测试、打包发布。

---

### 任务 4.1: 性能优化

**优先级**: P0  
**预计时间**: 3-4 天

#### 子任务

1. **内存优化**
   - 音频流使用缓冲池
   - 上下文历史长度限制
   - 定期清理过期会话

2. **响应优化**
   - 并行调用独立工具
   - 添加超时控制
   - 实现缓存机制 (工具列表、配置等)

3. **启动优化**
   - MCP Server 懒加载
   - 并发启动多个 Server

**验收标准**:
- ✅ 内存占用 < 200MB (空闲), < 500MB (运行)
- ✅ CPU 占用 < 3% (监听), < 20% (处理)
- ✅ 应用启动时间 < 2s

---

### 任务 4.2: 全面测试

**优先级**: P0  
**预计时间**: 3-4 天

#### 测试类型

1. **单元测试**
   - STT 模块测试
   - AI 引擎测试
   - MCP 客户端测试
   - 目标覆盖率 > 80%

2. **集成测试**
   - 端到端流程测试
   - 所有工具测试
   - 错误场景测试

3. **用户测试**
   - 内部团队使用测试
   - 收集反馈并修复问题

**验收标准**:
- ✅ 所有单元测试通过
- ✅ 所有集成测试通过
- ✅ 用户测试无重大问题

---

### 任务 4.3: 文档完善

**优先级**: P1  
**预计时间**: 2-3 天

#### 文档列表

1. **用户文档**
   - 安装指南
   - 使用教程
   - 常见问题 FAQ
   - 隐私政策

2. **开发文档**
   - 架构设计文档 ✅
   - API 文档
   - MCP 工具开发指南
   - 贡献指南

**验收标准**:
- ✅ 所有文档完成
- ✅ 文档清晰易懂

---

### 任务 4.4: 应用打包与发布

**优先级**: P0  
**预计时间**: 1-2 天

#### 子任务

1. **应用打包**
   - 配置 Xcode Archive
   - 签名和公证
   - 创建 DMG 安装包

2. **发布到 GitHub**
   - 创建 Release
   - 上传安装包
   - 编写 Release Notes

**验收标准**:
- ✅ 应用可以独立安装运行
- ✅ 发布到 GitHub Releases
- ✅ Release Notes 完整

---

## 6. 测试用例矩阵

### 6.1 核心功能测试

| 用例 ID | 场景 | 输入 | 预期输出 | 优先级 |
|---------|------|------|----------|--------|
| TC001 | 地图导航-完整地址 | "从北京到上海" | 打开地图,显示路线 | P0 |
| TC002 | 地图导航-仅终点 | "去天安门" | 使用当前位置为起点 | P0 |
| TC003 | 天气查询-今天 | "今天天气怎么样" | 显示当前位置今日天气 | P0 |
| TC004 | 天气查询-明天+地点 | "明天上海天气" | 显示上海明日天气 | P0 |
| TC005 | 音乐播放 | "播放周杰伦的晴天" | 打开音乐应用并播放 | P1 |
| TC006 | 应用启动 | "打开 Safari" | 启动 Safari 浏览器 | P1 |
| TC007 | 系统控制-音量 | "音量调到 50%" | 系统音量调整为 50% | P1 |
| TC008 | 浏览器控制 | "打开百度搜索苹果" | 打开百度并搜索 | P1 |
| TC009 | 多轮对话 | "查看上海天气" → "明天呢?" | 显示明天上海天气 | P1 |
| TC010 | 错误处理 | "打开 xxx 地图"(无效) | 提示无法理解,引导用户 | P2 |

### 6.2 异常场景测试

| 用例 ID | 场景 | 输入 | 预期输出 | 优先级 |
|---------|------|------|----------|--------|
| TC101 | 网络断开 | 天气查询 | 提示网络错误,引导重试 | P1 |
| TC102 | STT 失败 | 语音输入 | 自动降级到备用 STT | P1 |
| TC103 | LLM 超时 | 文字输入 | 提示处理超时,引导重试 | P1 |
| TC104 | 工具调用失败 | 地图导航 | 提示工具失败,显示错误信息 | P1 |
| TC105 | 权限未授予 | 麦克风访问 | 提示需要授予权限 | P0 |

---

## 7. 风险与挑战

### 7.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 | 负责人 |
|------|------|------|----------|--------|
| 唤醒词误触发率高 | 用户体验差 | 中 | 使用成熟引擎,可调灵敏度 | Swift 开发 |
| STT 准确率不足 | 功能不可用 | 中 | 多 STT 引擎降级 | Go 开发 |
| MCP 协议集成复杂 | 进度延期 | 中 | 参考官方示例,简化实现 | Go 开发 |
| 浏览器控制不稳定 | 功能受限 | 高 | 充分测试,提供降级方案 | MCP 工具开发 |

### 7.2 时间风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 开发时间估计不足 | 延期 | 中 | 优先完成 P0 任务,P1/P2 可延后 |
| 测试时间不足 | 质量问题 | 中 | 边开发边测试,及早发现问题 |
| 第三方 API 限流 | 功能受限 | 低 | 支持本地模型,降低依赖 |

---

## 8. 资源需求

### 8.1 开发资源

| 角色 | 人数 | 技能要求 |
|------|------|----------|
| macOS 开发工程师 | 1 | Swift, SwiftUI, AVFoundation |
| 后端开发工程师 | 1 | Go, gRPC, AI/LLM 集成 |
| MCP 工具开发工程师 | 1 | TypeScript/Python/Go, MCP 协议 |

### 8.2 外部资源

| 资源 | 用途 | 成本 |
|------|------|------|
| 阿里云 STT API | 语音识别 | 按量付费 |
| OpenAI API | AI 理解引擎 | 按量付费 |
| 彩云天气 API | 天气查询 | 免费额度 |
| 百度地图 API | 地图导航 | 免费 |

---

## 9. 里程碑与交付物

| 里程碑 | 时间节点 | 交付物 | 验收标准 |
|--------|----------|--------|----------|
| M1: MVP Demo | 第 2-3 周 | 地图导航功能 | 端到端流程可用 |
| M2: Beta 版本 | 第 5-6 周 | 4 种操作类型 | 天气、音乐、应用启动可用 |
| M3: RC 版本 | 第 7-8 周 | 所有核心功能 | 浏览器控制、系统控制可用 |
| M4: V1.0 正式版 | 第 9-10 周 | 优化版本 | 性能达标,文档完善 |

---

## 10. 下一步行动

### 立即开始 (本周)

1. **环境搭建**
   - [ ] 安装 Xcode
   - [ ] 安装 Go 和 Node.js
   - [ ] 创建项目结构

2. **技术验证**
   - [ ] 测试 Porcupine 唤醒词引擎
   - [ ] 测试阿里云 STT API
   - [ ] 测试 ChatGPT Function Calling
   - [ ] 测试 MCP SDK

3. **启动 MVP 开发**
   - [ ] 任务 1.1: 项目初始化
   - [ ] 任务 1.2: Swift macOS 应用框架
   - [ ] 任务 1.3: 语音输入模块

### 短期计划 (2 周内)

1. **完成 MVP**
   - [ ] 完成所有阶段一任务
   - [ ] 内部 Demo 演示

2. **启动阶段二**
   - [ ] 天气查询工具
   - [ ] 音乐播放工具

---

## 11. 总结

本文档详细拆解了 WALL-E 项目的所有开发任务,包括:

1. **4 个开发阶段**: MVP → 功能扩展 → 高级能力 → 优化发布
2. **30+ 个具体任务**: 每个任务都有明确的目标、时间、验收标准
3. **完整的测试用例**: 覆盖核心功能和异常场景
4. **风险缓解措施**: 识别技术风险并提供解决方案

**关键成功因素**:
- 优先完成 P0 任务,确保核心功能可用
- 边开发边测试,及早发现问题
- 保持代码质量,为后续扩展打好基础
- 充分利用现有开源工具和 SDK,避免重复造轮子

**预期结果**:
按照本计划执行,可在 8-10 周内完成一个功能完整、性能优秀、用户体验良好的 AI 桌面助手产品。