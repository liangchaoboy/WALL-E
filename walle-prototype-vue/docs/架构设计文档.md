# 架构设计文档 (Architecture Design Document)
# WALL-E: AI 驱动的桌面操作系统代理

---

## 📑 文档信息

| 项目 | 内容 |
|------|------|
| **项目名称** | WALL-E (AI Copilot for PC) |
| **版本** | v1.0 |
| **文档类型** | 架构设计文档 (ADD) |
| **创建日期** | 2025-10-26 |
| **基于** | PRD v3.0 |

---

## 1. 架构概览

> **注**: 本文档包含两个架构版本:
> - **当前实现版本** (tao 分支): Vue + Go + FastGPT + MCP (已实现)
> - **规划版本**: Swift + Go (未来迁移目标)

### 1.1 当前实现架构图 (tao 分支)

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户交互层 (UI Layer - Web)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │           Vue.js 语音助手前端 (voice-assistant)            │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │ • 浏览器麦克风采集 (getUserMedia)                          │   │
│  │ • Web Speech API 语音识别                                 │   │
│  │ • 实时语音活动检测 (VAD)                                   │   │
│  │ • 对话界面显示                                             │   │
│  │ • 调试日志面板                                             │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │ HTTP GET /get-text?text=xxx           │
└─────────────────────────┼────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                   应用服务层 (WALL-E-SERVE - Go)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Gin HTTP 服务器 (端口 9004)                   │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │ GET /get-text                                             │   │
│  │  1. 接收用户文本输入                                        │   │
│  │  2. 调用 FastGPT API (fast.ChatCompletion)                │   │
│  │  3. 解析返回的 data 和 url                                 │   │
│  │  4. 返回 JSON: {data: "...", url: "..."}                 │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │           FastGPT 客户端 (fast/fastgpt.go)                │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │ • HTTP 调用 FastGPT API (8.219.59.3:3000)                │   │
│  │ • 解析两种响应模式:                                         │   │
│  │   - JSON 模式: {data: "...", url: "..."}                 │   │
│  │   - 纯文本模式: 直接返回文本                                │   │
│  │ • 支持工具调用 (Tool Calls)                                │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
└─────────────────────────┼────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                   AI 平台层 (FastGPT + QWen)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              FastGPT 平台 (云端部署)                       │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │ • QWen 大模型理解用户意图                                   │   │
│  │ • MCP 工具集成和调用                                        │   │
│  │ • 返回结构化响应                                            │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │ MCP 协议调用                           │
└─────────────────────────┼────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                   MCP 工具层 (WALL-E-MCP - Go)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │         MCP 地图导航服务器 (端口 10087)                     │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │ 工具: navigate_map                                         │   │
│  │  • 参数: start, end, mapProvider (baidu/amap/google)     │   │
│  │  • 功能: 生成导航 URL                                      │   │
│  │  • 实现:                                                   │   │
│  │    - navigation/navigation.go: 核心导航逻辑               │   │
│  │    - mapprovider/provider.go: 地图提供商适配              │   │
│  │      * 百度地图 (国内首选)                                 │   │
│  │      * 高德地图 (国内备选)                                 │   │
│  │      * Google Maps (国际路线)                             │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                   │
│  可扩展: 支持添加更多 MCP 工具 (天气、音乐等)                      │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 规划架构图 (未来版本)

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户交互层 (UI Layer)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────┐    ┌──────────────────────────┐   │
│  │   语音输入模块              │    │   文字输入模块            │   │
│  │  (Voice Input Module)     │    │  (Text Input Module)     │   │
│  ├──────────────────────────┤    ├──────────────────────────┤   │
│  │ • 唤醒词检测 (Porcupine)   │    │ • 系统托盘图标            │   │
│  │ • 麦克风音频采集           │    │ • 全局快捷键 (Cmd+Space) │   │
│  │ • 实时音频流处理           │    │ • 输入框界面 (SwiftUI)   │   │
│  │ • VAD (语音活动检测)       │    │ • 历史记录查看            │   │
│  └──────────┬───────────────┘    └──────────┬───────────────┘   │
│             │                               │                    │
│             └───────────────┬───────────────┘                    │
│                             │                                    │
└─────────────────────────────┼────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      核心处理层 (Core Layer)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              输入处理模块 (Input Processor)               │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  STT 引擎管理器                                           │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │   │
│  │  │ 阿里云 STT   │ │ Whisper STT │ │ 本地 STT    │        │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘        │   │
│  │  • 自动降级策略                                           │   │
│  │  • 文本预处理和标准化                                      │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         ↓                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            AI 理解引擎 (AI Understanding Engine)          │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  LLM 调用层                                               │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │   │
│  │  │  ChatGPT    │ │   Claude    │ │  DeepSeek   │        │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘        │   │
│  │                                                            │   │
│  │  核心能力:                                                 │   │
│  │  • 意图识别 (Intent Recognition)                          │   │
│  │  • 参数提取 (Parameter Extraction)                        │   │
│  │  • 上下文管理 (Context Management)                        │   │
│  │  • 工具选择 (Tool Selection via MCP)                      │   │
│  │  • 多轮对话 (Multi-turn Dialog)                           │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         ↓                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              MCP 客户端 (MCP Client)                      │   │
│  ├──────────────────────────────────────────────────────────┤   │
│  │  • MCP Server 生命周期管理                                │   │
│  │  • 工具发现和注册                                          │   │
│  │  • 工具调用路由                                            │   │
│  │  • 结果聚合和错误处理                                       │   │
│  │  • 工具链编排 (Multi-step orchestration)                  │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
└─────────────────────────┼────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                    MCP 工具层 (MCP Tools Layer)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │ 地图导航     │ │ 天气查询     │ │ 音乐播放     │               │
│  │ MCP Server  │ │ MCP Server  │ │ MCP Server  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
│                                                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │ 浏览器控制   │ │ 系统控制     │ │ 应用启动     │               │
│  │ MCP Server  │ │ MCP Server  │ │ MCP Server  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
│                                                                   │
│  可扩展插件架构 - 支持第三方 MCP Server                            │
│                                                                   │
└─────────────────────────┬───────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                   系统能力层 (System Layer)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  • macOS 系统 API (AppKit, Foundation, AVFoundation)             │
│  • 第三方服务 API (地图服务、天气服务、音乐服务)                     │
│  • 浏览器自动化 (Playwright, AppleScript)                         │
│  • 系统权限管理 (Microphone, Accessibility, Network)              │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 当前实现详解 (tao 分支)

### 2.1 前端模块 (voice-assistant)

#### 技术栈
- **框架**: Vue.js 2.x
- **语音识别**: Web Speech API (浏览器原生)
- **音频采集**: MediaDevices.getUserMedia
- **UI**: Vue 组件 + 自定义 CSS

#### 核心组件

**App.vue 主组件**
```vue
export default {
  data() {
    return {
      isListening: false,        // 是否正在监听
      permissionGranted: false,  // 麦克风权限
      statusText: '',            // 状态文本
      responseText: '',          // AI 响应文本
      debugLogs: [],             // 调试日志
      recognition: null,         // 语音识别实例
    }
  },
  methods: {
    // 初始化语音识别
    initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || 
                                window.webkitSpeechRecognition
      this.recognition = new SpeechRecognition()
      this.recognition.lang = 'zh-CN'
      this.recognition.continuous = true
      this.recognition.interimResults = false
      
      // 识别结果处理
      this.recognition.onresult = (event) => {
        const transcript = event.results[event.results.length - 1][0].transcript
        this.sendToNavigationServer(transcript)
      }
    },
    
    // 发送请求到后端服务
    async sendToNavigationServer(text) {
      const encodedText = encodeURIComponent(text)
      const response = await fetch(`http://localhost:9004/get-text?text=${encodedText}`)
      const data = await response.json()
      
      // 显示 AI 响应
      this.addDebugLog(`小度: ${data.data}`)
      
      // 如果有 URL,打开新窗口
      if (data.url && data.url.trim() !== '') {
        const link = document.createElement('a')
        link.href = data.url
        link.target = '_blank'
        link.click()
      }
    }
  }
}
```

#### 数据流

```
用户说话 → 浏览器 getUserMedia → Web Speech API 识别
    ↓
识别完成 → 发送 HTTP GET /get-text?text=xxx
    ↓
接收响应 {data, url} → 显示对话 + 打开 URL
```

### 2.2 后端服务模块 (WALL-E-SERVE)

#### 技术栈
- **语言**: Go 1.x
- **Web 框架**: Gin
- **HTTP 客户端**: 标准库 net/http

#### 核心代码结构

**main.go - HTTP 服务器**
```go
func main() {
    router := gin.Default()
    
    // 配置 CORS (允许前端跨域访问)
    router.Use(cors.New(cors.Config{
        AllowOrigins: []string{"*"},
        AllowMethods: []string{"GET", "POST", "OPTIONS"},
        AllowHeaders: []string{"Origin", "Content-Type", "Authorization"},
    }))
    
    // GET /get-text 接口
    router.GET("/get-text", func(c *gin.Context) {
        text := c.Query("text")
        
        // 调用 FastGPT
        data, url, err := fast.ChatCompletion(text)
        if err != nil {
            c.JSON(http.StatusInternalServerError, 
                   gin.H{"error": "导航服务暂时不可用"})
            return
        }
        
        // 如果没有直接返回 URL,从 data 中提取
        if url == "" {
            re := regexp.MustCompile(`\[点击这里\]\((.*?)\)`)
            matches := re.FindStringSubmatch(data)
            if len(matches) >= 2 {
                url = matches[1]
            }
        }
        
        c.JSON(http.StatusOK, gin.H{
            "data": data,
            "url":  url,
        })
    })
    
    router.Run(":9004")
}
```

**fast/fastgpt.go - FastGPT 客户端**
```go
type AIReqData struct {
    ChatId    string                  `json:"chatId,omitempty"`
    Stream    bool                    `json:"stream,omitempty"`
    Messages  []ChatCompletionMessage `json:"messages"`
}

type ParsedChatCompletionResult struct {
    Id      string         `json:"id"`
    Model   string         `json:"model"`
    Choices []Choice       `json:"choices"`
    Parsed  []ParsedChoice `json:"parsed"` // 解析后的数据
}

type ParsedChoice struct {
    ContentData     *ContentData `json:"content_data,omitempty"`
    IsJSONContent   bool         `json:"is_json_content"`
    TextContent     string       `json:"text_content"`
}

type ContentData struct {
    Data string `json:"data,omitempty"` // AI 回复文本
    URL  string `json:"url,omitempty"`  // 导航 URL
}

func ChatCompletion(text string) (string, string, error) {
    request := AIReqData{
        Stream:   false,
        Messages: []ChatCompletionMessage{
            {Role: ChatMessageRoleUser, Content: text},
        },
    }
    
    result, err := ChatFromGPT(request)
    if err != nil {
        return "", "", err
    }
    
    // 根据响应类型返回
    if result.Parsed[0].IsJSONContent {
        // JSON 模式: 返回 data 和 url
        return result.Parsed[0].ContentData.Data, 
               result.Parsed[0].ContentData.URL, nil
    } else {
        // 纯文本模式
        return result.Parsed[0].TextContent, "", nil
    }
}
```

### 2.3 MCP 工具模块 (WALL-E-MCP)

#### 技术栈
- **语言**: Go 1.x
- **MCP SDK**: github.com/mark3labs/mcp-go
- **服务器**: SSE (Server-Sent Events) 模式

#### 核心代码结构

**main.go - MCP 服务器**
```go
func main() {
    // 创建 MCP 服务器
    s := server.NewMCPServer(
        "map-navigation-mcp",
        "1.0.0",
        server.WithLogging(),
    )
    
    // 注册工具: navigate_map
    navigateMapTool := mcp.NewTool("navigate_map",
        mcp.WithDescription("当用户想要导航时使用此工具"),
        mcp.WithString("start", 
            mcp.Required(),
            mcp.Description("导航起点")),
        mcp.WithString("end",
            mcp.Required(),
            mcp.Description("导航终点")),
        mcp.WithString("mapProvider",
            mcp.Description("地图服务: baidu/amap/google"),
            mcp.Enum("baidu", "amap", "google")),
    )
    
    // 添加工具处理函数
    s.AddTool(navigateMapTool, handleNavigateMap)
    
    // 启动 SSE 服务器 (端口 10087)
    sseServer := server.NewSSEServer(s)
    sseServer.Start(":10087")
}

func handleNavigateMap(ctx context.Context, request mcp.CallToolRequest) 
    (*mcp.CallToolResult, error) {
    // 解析参数
    args := request.Params.Arguments.(map[string]interface{})
    navArgs := navigation.NavigateMapArgs{
        Start:       args["start"].(string),
        End:         args["end"].(string),
        MapProvider: mapprovider.MapProvider(args["mapProvider"].(string)),
    }
    
    // 生成导航 URL
    url, err := navigation.NavigateMap(navArgs)
    if err != nil {
        return mcp.NewToolResultError(err.Error()), nil
    }
    
    return mcp.NewToolResultText(url), nil
}
```

**navigation/navigation.go - 导航逻辑**
```go
type NavigateMapArgs struct {
    Start       string
    End         string
    MapProvider mapprovider.MapProvider
}

func NavigateMap(args NavigateMapArgs) (string, error) {
    // 默认使用百度地图
    if args.MapProvider == "" {
        args.MapProvider = mapprovider.Baidu
    }
    
    // 参数验证
    if args.Start == "" || args.End == "" {
        return "", fmt.Errorf("起点和终点不能为空")
    }
    
    // 生成导航 URL
    params := mapprovider.NavigationParams{
        Start:       args.Start,
        End:         args.End,
        MapProvider: args.MapProvider,
    }
    
    url, err := mapprovider.GenerateNavigationURL(params)
    return url, err
}
```

**mapprovider/provider.go - 地图提供商**
```go
type MapProvider string

const (
    Baidu  MapProvider = "baidu"
    Amap   MapProvider = "amap"
    Google MapProvider = "google"
)

func GenerateBaiduMapURL(start, end string) string {
    baseURL := "http://api.map.baidu.com/direction"
    params := url.Values{}
    params.Add("origin", start)
    params.Add("destination", end)
    params.Add("mode", "transit")  // 公交模式
    params.Add("region", extractCityName(end))
    params.Add("output", "html")
    return fmt.Sprintf("%s?%s", baseURL, params.Encode())
}

func GenerateAmapURL(start, end string) string {
    baseURL := "https://www.amap.com/dir"
    params := url.Values{}
    params.Add("from", start)
    params.Add("to", end)
    return fmt.Sprintf("%s?%s", baseURL, params.Encode())
}

func GenerateGoogleMapsURL(start, end string) string {
    baseURL := "https://www.google.com/maps/dir/"
    params := url.Values{}
    params.Add("api", "1")
    params.Add("origin", start)
    params.Add("destination", end)
    params.Add("travelmode", "transit")
    return fmt.Sprintf("%s?%s", baseURL, params.Encode())
}
```

### 2.4 完整数据流

```
1. 用户语音输入 "从上海七牛云到虹桥机场"
   ↓
2. Vue 前端: Web Speech API 识别为文本
   ↓
3. HTTP GET http://localhost:9004/get-text?text=从上海七牛云到虹桥机场
   ↓
4. WALL-E-SERVE: 接收请求
   ↓
5. 调用 FastGPT API (云端)
   POST http://8.219.59.3:3000/api/v1/chat/completions
   Body: {
     "messages": [{"role": "user", "content": "从上海七牛云到虹桥机场"}]
   }
   ↓
6. FastGPT 平台:
   - QWen 大模型理解意图 → 需要调用 navigate_map 工具
   - 调用 WALL-E-MCP 服务 (端口 10087)
   - MCP 请求: {
       "method": "tools/call",
       "params": {
         "name": "navigate_map",
         "arguments": {
           "start": "上海七牛云",
           "end": "虹桥机场",
           "mapProvider": "baidu"
         }
       }
     }
   ↓
7. WALL-E-MCP: 处理 navigate_map
   - navigation.NavigateMap() 生成导航 URL
   - mapprovider.GenerateBaiduMapURL()
   - 返回: "http://api.map.baidu.com/direction?origin=上海七牛云&destination=虹桥机场..."
   ↓
8. FastGPT 返回给 WALL-E-SERVE:
   {
     "choices": [{
       "message": {
         "content": "{\"data\": \"已为您打开导航\", \"url\": \"http://...\"}"
       }
     }]
   }
   ↓
9. WALL-E-SERVE 解析并返回给前端:
   {
     "data": "已为您打开导航",
     "url": "http://api.map.baidu.com/direction?..."
   }
   ↓
10. Vue 前端:
    - 显示对话: "小度: 已为您打开导航"
    - 打开新窗口: window.open(url)
```

### 2.5 部署与运行

#### 项目结构 (tao 分支)
```
/
├── voice-assistant/        # Vue 前端
│   ├── src/
│   │   ├── App.vue        # 主组件
│   │   └── main.js
│   ├── package.json
│   └── vue.config.js
│
├── WALL-E-SERVE/          # Go 后端服务
│   ├── main.go           # HTTP 服务器
│   ├── fast/
│   │   └── fastgpt.go    # FastGPT 客户端
│   └── go.mod
│
├── WALL-E-MCP/            # MCP 工具服务
│   ├── main.go           # MCP 服务器
│   ├── navigation/
│   │   └── navigation.go
│   ├── mapprovider/
│   │   └── provider.go
│   └── go.mod
│
└── Makefile              # 构建和运行脚本
```

#### 运行命令 (Makefile)
```makefile
# 安装前端依赖
build-env:
    cd voice-assistant; npm install

# 启动前端 (端口 8080)
run-site:
    cd voice-assistant; npm run serve

# 启动 MCP 服务 (端口 10087, 云端已部署)
run-mcp:
    cd WALL-E-MCP; go run main.go

# 启动后端服务 (端口 9004)
run-serve:
    export FASTGPT_API_KEY="your_api_key" && \
    cd WALL-E-SERVE && \
    go run main.go
```

#### 配置要求
- **FASTGPT_API_KEY**: FastGPT 平台的 API 密钥 (联系团队获取)
- **端口占用**: 
  - 8080: Vue 前端
  - 9004: Go 后端服务
  - 10087: MCP 服务 (可选,云端已部署)

---

## 3. 规划架构设计 (未来版本)

### 3.1 语音输入模块 (Voice Input Module)

#### 技术栈
- **语言**: Swift
- **框架**: AVFoundation (音频采集)
- **唤醒词引擎**: Porcupine (本地检测)
- **VAD**: WebRTC VAD 或 Silero VAD

#### 组件设计

```swift
// 唤醒词检测器
class WakeWordDetector {
    private let porcupineManager: PorcupineManager
    
    func start() // 开始监听
    func stop()  // 停止监听
    func onWakeWordDetected(handler: () -> Void) // 唤醒回调
}

// 音频采集器
class AudioCapture {
    private let audioEngine: AVAudioEngine
    
    func startRecording() -> AsyncStream<AudioBuffer>
    func stopRecording()
}

// VAD 检测器
class VoiceActivityDetector {
    func processSample(_ buffer: AudioBuffer) -> Bool // 是否检测到语音
    func didSpeechEnd() -> Bool // 是否说话结束
}

// 语音输入协调器
class VoiceInputCoordinator {
    private let wakeWordDetector: WakeWordDetector
    private let audioCapture: AudioCapture
    private let vad: VoiceActivityDetector
    
    func startListening()
    func onVoiceInput(handler: (Data) -> Void) // 返回音频数据
}
```

#### 数据流

```
用户说话 → 麦克风采集 → 唤醒词检测 (Porcupine)
    ↓
检测到唤醒词 → 开始录音 → VAD 检测
    ↓
语音结束 (VAD) → 音频数据 → 发送至 STT 引擎
```

---

### 2.2 文字输入模块 (Text Input Module)

#### 技术栈
- **语言**: Swift
- **框架**: SwiftUI, AppKit

#### 组件设计

```swift
// 系统托盘管理器
class SystemTrayManager {
    func createStatusBarItem()
    func showInputWindow()
}

// 输入窗口
struct InputWindow: View {
    @State var inputText: String
    @State var history: [HistoryItem]
    
    var body: some View {
        VStack {
            TextField("输入指令...", text: $inputText)
            HistoryListView(history: history)
        }
    }
}

// 全局快捷键管理器
class GlobalHotKeyManager {
    func registerHotKey(_ key: KeyCombo, handler: () -> Void)
}

// 文字输入协调器
class TextInputCoordinator {
    private let trayManager: SystemTrayManager
    private let hotKeyManager: GlobalHotKeyManager
    
    func setupUI()
    func onTextInput(handler: (String) -> Void)
}
```

---

### 2.3 输入处理模块 (Input Processor)

#### 技术栈
- **语言**: Go
- **STT 引擎**:
  - 阿里云语音识别 SDK
  - OpenAI Whisper API
  - 本地 Whisper 模型 (whisper.cpp)

#### 组件设计

```go
// STT 引擎接口
type STTEngine interface {
    Transcribe(audioData []byte) (string, error)
}

// 阿里云 STT
type AliyunSTT struct {
    client *alibabacloud.Client
}

// Whisper STT
type WhisperSTT struct {
    apiKey string
}

// 本地 Whisper
type LocalWhisperSTT struct {
    modelPath string
}

// STT 管理器 (支持降级策略)
type STTManager struct {
    engines []STTEngine
    fallbackEnabled bool
}

func (m *STTManager) Transcribe(audio []byte) (string, error) {
    // 依次尝试各引擎,失败则降级
    for _, engine := range m.engines {
        text, err := engine.Transcribe(audio)
        if err == nil {
            return text, nil
        }
    }
    return "", errors.New("all STT engines failed")
}
```

#### 文本预处理

```go
type TextPreprocessor struct{}

func (p *TextPreprocessor) Normalize(text string) string {
    // 1. 去除多余空格
    // 2. 繁简转换
    // 3. 标点标准化
    // 4. 数字规范化 (如"一百" -> "100")
    return normalizedText
}
```

---

### 2.4 AI 理解引擎 (AI Understanding Engine)

#### 技术栈
- **语言**: Go
- **LLM**: 支持多种 LLM (ChatGPT, Claude, DeepSeek)
- **协议**: MCP (Model Context Protocol)

#### 核心设计

```go
// LLM 客户端接口
type LLMClient interface {
    Chat(ctx context.Context, messages []Message, tools []Tool) (*Response, error)
}

// 意图理解结果
type Intent struct {
    Name       string                 // 意图名称 (如 "navigate_map")
    Confidence float64                // 置信度
    Parameters map[string]interface{} // 参数
    ToolCalls  []ToolCall             // 需要调用的工具
}

// AI 理解引擎
type AIEngine struct {
    llmClient    LLMClient
    mcpClient    *MCPClient
    contextStore *ContextStore // 上下文存储
}

func (e *AIEngine) Understand(ctx context.Context, input string) (*Intent, error) {
    // 1. 获取上下文
    context := e.contextStore.GetContext()
    
    // 2. 构造消息
    messages := e.buildMessages(input, context)
    
    // 3. 获取可用工具列表
    tools := e.mcpClient.GetAvailableTools()
    
    // 4. 调用 LLM (支持 Function Calling)
    response, err := e.llmClient.Chat(ctx, messages, tools)
    if err != nil {
        return nil, err
    }
    
    // 5. 解析意图和参数
    intent := e.parseIntent(response)
    
    // 6. 更新上下文
    e.contextStore.UpdateContext(input, intent)
    
    return intent, nil
}
```

#### 上下文管理

```go
type ContextStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    SessionID   string
    Messages    []Message
    LastIntent  *Intent
    CreatedAt   time.Time
    LastActiveAt time.Time
}

func (c *ContextStore) GetContext() []Message {
    // 返回最近 N 轮对话历史
}

func (c *ContextStore) UpdateContext(input string, intent *Intent) {
    // 更新会话状态
}
```

---

### 2.5 MCP 客户端 (MCP Client)

#### 技术栈
- **语言**: Go
- **SDK**: github.com/modelcontextprotocol/sdk-go

#### 核心设计

```go
// MCP 客户端
type MCPClient struct {
    servers map[string]*MCPServer
    tools   map[string]*Tool
}

// MCP Server 连接
type MCPServer struct {
    Name       string
    Connection *mcp.Connection
    Status     ServerStatus
}

// 工具定义
type Tool struct {
    Name        string
    Description string
    InputSchema JSONSchema
    ServerName  string
}

// 启动所有 MCP Server
func (c *MCPClient) StartServers(configs []ServerConfig) error {
    for _, config := range configs {
        server, err := c.connectServer(config)
        if err != nil {
            log.Errorf("failed to connect server %s: %v", config.Name, err)
            continue
        }
        c.servers[config.Name] = server
        
        // 发现工具
        tools, err := server.ListTools()
        if err != nil {
            log.Errorf("failed to list tools from %s: %v", config.Name, err)
            continue
        }
        
        // 注册工具
        for _, tool := range tools {
            c.tools[tool.Name] = tool
        }
    }
    return nil
}

// 调用工具
func (c *MCPClient) CallTool(ctx context.Context, toolName string, params map[string]interface{}) (*ToolResult, error) {
    tool, exists := c.tools[toolName]
    if !exists {
        return nil, fmt.Errorf("tool %s not found", toolName)
    }
    
    // 验证参数
    if err := tool.ValidateParams(params); err != nil {
        return nil, err
    }
    
    // 获取对应的 server
    server := c.servers[tool.ServerName]
    
    // 调用工具
    result, err := server.CallTool(ctx, toolName, params)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}

// 获取可用工具列表 (供 LLM Function Calling 使用)
func (c *MCPClient) GetAvailableTools() []Tool {
    tools := make([]Tool, 0, len(c.tools))
    for _, tool := range c.tools {
        tools = append(tools, *tool)
    }
    return tools
}
```

#### 工具链编排

```go
// 工具链编排器 (支持多步骤操作)
type ToolOrchestrator struct {
    mcpClient *MCPClient
}

func (o *ToolOrchestrator) ExecuteChain(ctx context.Context, toolCalls []ToolCall) ([]ToolResult, error) {
    results := make([]ToolResult, 0, len(toolCalls))
    
    for _, call := range toolCalls {
        result, err := o.mcpClient.CallTool(ctx, call.Name, call.Parameters)
        if err != nil {
            // 错误处理: 继续执行还是中断?
            if call.Required {
                return results, err
            }
            log.Warnf("optional tool %s failed: %v", call.Name, err)
            continue
        }
        results = append(results, *result)
    }
    
    return results, nil
}
```

---

### 2.6 MCP 工具层 (MCP Tools)

#### 2.6.1 地图导航工具

**实现语言**: TypeScript/Node.js

```typescript
// 地图导航 MCP Server
import { Server } from '@modelcontextprotocol/sdk';

const server = new Server({
  name: 'map-navigation',
  version: '1.0.0',
});

server.setRequestHandler('tools/list', async () => ({
  tools: [
    {
      name: 'navigate_map',
      description: '打开地图应用并导航到指定地点',
      inputSchema: {
        type: 'object',
        properties: {
          origin: { type: 'string', description: '起点地址' },
          destination: { type: 'string', description: '目的地地址' },
          mapProvider: { 
            type: 'string', 
            enum: ['baidu', 'amap', 'google'],
            default: 'baidu' 
          },
          routeType: {
            type: 'string',
            enum: ['driving', 'walking', 'transit', 'cycling'],
            default: 'driving'
          }
        },
        required: ['destination']
      }
    }
  ]
}));

server.setRequestHandler('tools/call', async (request) => {
  const { name, arguments: args } = request.params;
  
  if (name === 'navigate_map') {
    const url = buildMapURL(args);
    await openURL(url); // 使用 macOS open 命令或浏览器打开
    
    return {
      content: [
        {
          type: 'text',
          text: `已打开地图导航: ${args.origin || '当前位置'} → ${args.destination}`
        }
      ]
    };
  }
});
```

#### 2.6.2 天气查询工具

**实现语言**: Python

```python
from mcp.server import Server
from mcp.types import Tool, TextContent
import requests

app = Server("weather-query")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="query_weather",
            description="查询指定地点的天气信息",
            inputSchema={
                "type": "object",
                "properties": {
                    "location": {"type": "string", "description": "地点名称"},
                    "date": {"type": "string", "description": "日期 (today/tomorrow/日期)"},
                },
                "required": ["location"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "query_weather":
        location = arguments["location"]
        date = arguments.get("date", "today")
        
        # 调用天气 API (彩云天气/和风天气)
        weather_data = fetch_weather(location, date)
        
        return [
            TextContent(
                type="text",
                text=format_weather_info(weather_data)
            )
        ]
```

#### 2.6.3 音乐播放工具

**实现语言**: Go

```go
package main

import (
    "github.com/modelcontextprotocol/sdk-go/mcp"
)

func main() {
    server := mcp.NewServer("music-player", "1.0.0")
    
    server.HandleListTools(func() ([]mcp.Tool, error) {
        return []mcp.Tool{
            {
                Name:        "play_music",
                Description: "播放指定的音乐",
                InputSchema: map[string]interface{}{
                    "type": "object",
                    "properties": map[string]interface{}{
                        "song":   map[string]string{"type": "string", "description": "歌曲名称"},
                        "artist": map[string]string{"type": "string", "description": "歌手名称"},
                        "app":    map[string]interface{}{
                            "type": "string",
                            "enum": []string{"netease", "qq", "spotify", "apple"},
                            "default": "netease",
                        },
                    },
                    "required": []string{"song"},
                },
            },
        }, nil
    })
    
    server.HandleCallTool(func(name string, params map[string]interface{}) (*mcp.ToolResult, error) {
        if name == "play_music" {
            // 通过 AppleScript 或 API 控制音乐应用
            err := playMusicViaAppleScript(params)
            if err != nil {
                return nil, err
            }
            return &mcp.ToolResult{
                Content: []mcp.Content{
                    {Type: "text", Text: "正在播放音乐..."},
                },
            }, nil
        }
        return nil, fmt.Errorf("unknown tool: %s", name)
    })
    
    server.Start()
}
```

---

## 3. 数据模型设计

### 3.1 配置数据

```go
// 应用配置
type AppConfig struct {
    // 语音配置
    Voice struct {
        WakeWord       string   `json:"wake_word"`        // 唤醒词
        STTEngine      string   `json:"stt_engine"`       // 默认 STT 引擎
        STTFallback    bool     `json:"stt_fallback"`     // 是否启用降级
        VADSensitivity float64  `json:"vad_sensitivity"`  // VAD 灵敏度
    } `json:"voice"`
    
    // AI 配置
    AI struct {
        LLMProvider string `json:"llm_provider"` // ChatGPT/Claude/DeepSeek
        APIKey      string `json:"api_key"`
        Model       string `json:"model"`
        Temperature float64 `json:"temperature"`
    } `json:"ai"`
    
    // MCP 配置
    MCP struct {
        Servers []ServerConfig `json:"servers"`
    } `json:"mcp"`
    
    // UI 配置
    UI struct {
        HotKey      string `json:"hot_key"`       // 全局快捷键
        LaunchAtLogin bool `json:"launch_at_login"`
    } `json:"ui"`
}

// MCP Server 配置
type ServerConfig struct {
    Name    string                 `json:"name"`
    Command string                 `json:"command"` // 启动命令
    Args    []string               `json:"args"`
    Env     map[string]string      `json:"env"`
    Enabled bool                   `json:"enabled"`
}
```

### 3.2 持久化数据

```go
// 历史记录
type HistoryItem struct {
    ID        string    `db:"id"`
    SessionID string    `db:"session_id"`
    Input     string    `db:"input"`      // 用户输入
    Intent    string    `db:"intent"`     // 识别的意图
    ToolCalls string    `db:"tool_calls"` // JSON 序列化的工具调用
    Result    string    `db:"result"`     // 执行结果
    Success   bool      `db:"success"`
    CreatedAt time.Time `db:"created_at"`
}

// 使用统计
type UsageStats struct {
    Date       string `db:"date"`        // YYYY-MM-DD
    ToolName   string `db:"tool_name"`
    CallCount  int    `db:"call_count"`
    SuccessRate float64 `db:"success_rate"`
}
```

---

## 4. 通信协议设计

### 4.1 Swift ↔ Go 进程间通信

**方案**: gRPC

```protobuf
syntax = "proto3";

package wallecli;

// 核心服务
service WALLEService {
    // 处理文字输入
    rpc ProcessTextInput(TextInputRequest) returns (TextInputResponse);
    
    // 处理语音输入
    rpc ProcessVoiceInput(VoiceInputRequest) returns (VoiceInputResponse);
    
    // 获取历史记录
    rpc GetHistory(HistoryRequest) returns (HistoryResponse);
    
    // 获取配置
    rpc GetConfig(ConfigRequest) returns (ConfigResponse);
    
    // 更新配置
    rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);
}

message TextInputRequest {
    string input = 1;
    string session_id = 2;
}

message VoiceInputRequest {
    bytes audio_data = 1;
    string audio_format = 2; // wav, pcm
    string session_id = 3;
}

message TextInputResponse {
    string intent = 1;
    map<string, string> parameters = 2;
    repeated ToolCallResult tool_results = 3;
    string feedback_text = 4; // 反馈文本 (用于 TTS)
    bool success = 5;
}

message ToolCallResult {
    string tool_name = 1;
    bool success = 2;
    string result = 3;
    string error = 4;
}
```

### 4.2 MCP 协议通信

遵循 MCP 标准协议 (基于 JSON-RPC 2.0)

**示例: 工具调用请求**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "navigate_map",
    "arguments": {
      "origin": "上海七牛云",
      "destination": "虹桥机场",
      "mapProvider": "baidu",
      "routeType": "driving"
    }
  }
}
```

**示例: 工具调用响应**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "已打开百度地图导航: 上海七牛云 → 虹桥机场"
      }
    ],
    "isError": false
  }
}
```

---

## 5. 安全设计

### 5.1 权限管理

```go
// 危险操作列表
var DangerousTools = map[string]bool{
    "system_shutdown":  true,
    "system_restart":   true,
    "delete_file":      true,
    "execute_command":  true,
}

// 权限检查器
type PermissionChecker struct {
    userConfirmations map[string]bool // 用户已确认的操作
}

func (p *PermissionChecker) CheckPermission(toolName string) (bool, error) {
    if DangerousTools[toolName] {
        // 危险操作需要用户确认
        if !p.userConfirmations[toolName] {
            return false, errors.New("需要用户确认")
        }
    }
    return true, nil
}
```

### 5.2 敏感数据保护

```go
// 使用 macOS Keychain 存储敏感信息
type SecureStorage struct {
    keychain *Keychain
}

func (s *SecureStorage) StoreAPIKey(provider string, apiKey string) error {
    return s.keychain.Set(fmt.Sprintf("wallecli.apikey.%s", provider), apiKey)
}

func (s *SecureStorage) GetAPIKey(provider string) (string, error) {
    return s.keychain.Get(fmt.Sprintf("wallecli.apikey.%s", provider))
}
```

### 5.3 日志脱敏

```go
// 日志脱敏
type SensitiveFilter struct {
    patterns []string // 敏感信息正则
}

func (f *SensitiveFilter) Filter(log string) string {
    // 替换密码、Token、API Key 等敏感信息
    filtered := log
    for _, pattern := range f.patterns {
        re := regexp.MustCompile(pattern)
        filtered = re.ReplaceAllString(filtered, "***")
    }
    return filtered
}
```

---

## 6. 性能优化

### 6.1 启动优化

- **懒加载**: MCP Server 按需启动,而非全部预加载
- **并发启动**: 多个 MCP Server 并发启动
- **缓存**: 工具列表缓存,避免重复查询

```go
func (c *MCPClient) LazyLoadServer(serverName string) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if _, exists := c.servers[serverName]; exists {
        return nil // 已加载
    }
    
    config := c.configs[serverName]
    server, err := c.connectServer(config)
    if err != nil {
        return err
    }
    
    c.servers[serverName] = server
    return nil
}
```

### 6.2 内存优化

- **音频流处理**: 使用流式处理,避免大块内存分配
- **上下文管理**: 限制上下文历史长度 (如最多保留 10 轮对话)
- **定期清理**: 定期清理过期的会话数据

### 6.3 响应优化

- **并行调用**: 独立工具并行调用
- **超时控制**: 每个工具调用设置超时
- **降级策略**: 工具失败时快速降级

---

## 7. 可扩展性设计

### 7.1 插件系统

支持第三方开发 MCP Server 插件

```yaml
# 插件市场配置示例
plugins:
  - name: weather-extended
    author: community
    version: 1.2.0
    description: 增强版天气查询工具
    install_command: npm install -g @wallecli/weather-extended
    server_config:
      command: weather-extended-server
      args: []
```

### 7.2 配置热更新

支持无需重启的配置更新

```go
type ConfigWatcher struct {
    configPath string
    onChange   func(*AppConfig)
}

func (w *ConfigWatcher) Watch() {
    // 监听配置文件变化
    // 变化时重新加载并触发 onChange 回调
}
```

---

## 8. 测试策略

### 8.1 单元测试

- **覆盖率目标**: > 80%
- **Mock**: 使用 Mock 隔离外部依赖 (LLM API, MCP Server)

### 8.2 集成测试

```go
func TestEndToEndFlow(t *testing.T) {
    // 启动测试用 MCP Server
    testServer := startTestMCPServer()
    defer testServer.Stop()
    
    // 创建 AI 引擎 (使用 Mock LLM)
    engine := NewAIEngine(mockLLM, testMCPClient)
    
    // 测试输入
    input := "查看明天上海的天气"
    
    // 执行
    intent, err := engine.Understand(context.Background(), input)
    require.NoError(t, err)
    
    // 验证
    assert.Equal(t, "query_weather", intent.Name)
    assert.Equal(t, "上海", intent.Parameters["location"])
    assert.Equal(t, "tomorrow", intent.Parameters["date"])
}
```

### 8.3 性能测试

- **启动时间**: < 2s
- **端到端延迟**: 文字输入 < 5s, 语音输入 < 10s
- **内存占用**: 空闲 < 200MB, 运行 < 500MB

---

## 9. 部署架构

### 9.1 应用结构

```
WALLE.app/
├── Contents/
│   ├── MacOS/
│   │   ├── WALLE              # Swift 可执行文件 (UI + 语音)
│   │   └── walle-core         # Go 可执行文件 (核心处理)
│   ├── Resources/
│   │   ├── models/
│   │   │   └── wakeword.ppn   # 唤醒词模型
│   │   ├── configs/
│   │   │   └── default.json   # 默认配置
│   │   └── mcp-servers/       # 内置 MCP Server
│   │       ├── map-navigation/
│   │       ├── weather-query/
│   │       └── music-player/
│   └── Info.plist
```

### 9.2 进程管理

- **主进程**: Swift 应用 (UI)
- **子进程**: Go 核心服务 (gRPC Server)
- **MCP Server 进程**: 按需启动的独立进程

```swift
// Swift 中启动 Go 核心服务
class CoreServiceManager {
    func startCoreService() {
        let corePath = Bundle.main.path(forResource: "walle-core", ofType: nil)!
        let process = Process()
        process.executableURL = URL(fileURLWithPath: corePath)
        process.arguments = ["--port", "50051"]
        try? process.run()
    }
}
```

---

## 10. 监控与日志

### 10.1 日志分级

```go
// 使用结构化日志 (如 zap)
logger := zap.NewProduction()

logger.Info("user input received",
    zap.String("input", userInput),
    zap.String("session_id", sessionID),
)

logger.Error("tool call failed",
    zap.String("tool", toolName),
    zap.Error(err),
)
```

### 10.2 性能指标采集

```go
// 记录关键操作的耗时
type Metrics struct {
    STTLatency     prometheus.Histogram
    AILatency      prometheus.Histogram
    ToolCallLatency prometheus.Histogram
}

func (m *Metrics) RecordSTTLatency(duration time.Duration) {
    m.STTLatency.Observe(duration.Seconds())
}
```

---

## 11. 总结

本架构设计文档详细描述了 WALL-E 系统的技术架构,包括:

1. **分层架构**: 用户交互层 → 核心处理层 → MCP 工具层 → 系统能力层
2. **核心模块**: 语音输入、文字输入、STT、AI 理解、MCP 客户端
3. **MCP 工具**: 地图导航、天气查询、音乐播放等可扩展工具
4. **通信协议**: gRPC (进程间) + MCP (工具调用)
5. **安全设计**: 权限管理、数据加密、日志脱敏
6. **性能优化**: 懒加载、并发、缓存
7. **可扩展性**: 插件系统、配置热更新

该架构支持快速迭代,可从 MVP 逐步演进到完整产品。